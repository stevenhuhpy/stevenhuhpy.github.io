<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>依赖注入原理-看这篇就够了</title>
    <url>/2020/07/02/donet/dependency_injection/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文是依赖注入技术的入门文章，基于 .NET 平台使用 C# 语言讲解。</p>
<p>如果对 C# 语言的基本特性和语法比较熟悉，那么理解起来会更加容易一些，其中包括，但不仅限于， C# 中的类，函数，接口。<br>如果对 C# 语言没有任何基础，但是了解其他面向对象的语言，那么应该也不妨碍你读懂这篇文章。</p>
<span id="more"></span>

<p>之前接触的一些框架和源码里有用到依赖注入容器，但当时我不知道依赖注入容器怎么用，更加不知道依赖注入技术是什么。我不清楚其他人第一次看到依赖注入容器的代码是什么感觉，至少我起初看到这些代码，是比较困惑的，因为没法连贯起代码的逻辑性，必要时，只能自己摸索着做些修改，然后运行程序看看结果。直到研究了依赖注入的思想和原理，才算搞明白其中的原委。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文大部分内容来自 Pluralsight 在线学习门户，主要目的是对阶段性学习做个总结分享，非用于商业用途。</p>
<h2 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h2><p>越来越多的框架植入了依赖注入容器。那么什么是依赖注入容器？要解答这个问题，我们得先了解什么是依赖注入。因为许多功能都隐藏在依赖注入容器背后，只学会依赖注入容器的使用而不了解依赖注入技术本身的原理，显然是管中窥豹可见一斑。</p>
<p><img src="What_is_DI.png" alt="No Images :("> </p>
<p>那么什么是依赖注入，依赖注入技术在我们的应用程序代码中起到了什么作用？这个问题每个人理解不同，自然有很多不同的答案，但基本大同小异。这里翻译了其中一种解释（原文可以参考 Mark Seemann 的书籍 Dependency Injection in .NET）。<br>让我们一起来看。</p>
<p>依赖注入，也就是 DI，英文 dependency injection 的缩写，是一系列用于开发解耦合代码的软件设计原则和模式。</p>
<p>这个定义不仅解释了什么是依赖注入：软件设计原则和模式。同时也告诉了我们依赖注入的作用：开发解耦合的代码。<br>所以，依赖注入是设计模式范畴的技术，和其他我们接触过的设计模式一样，主要是用于降低应用程序代码的耦合度。</p>
<p>那么又有问题来了，为什么我们关心耦合度，或者说，为什么我们追求解耦合的代码？有以下几点原因：</p>
<ul>
<li>解耦合的代码更加易于扩展。我们能够在不改变大量对象的情况下增加功能。</li>
<li>我们能够将功能独立开来，以便编写简短的，易于阅读的单元测试。</li>
<li>我们也获得了易于维护的代码。当程序出错的时候，我们能够更加容易发现我们需要修改哪部分内容。</li>
<li>我们在团队协作开发的过程中，比如提交合并代码，通常不希望也应该避免团队成员之间的代码存在冲突，而解耦合有利于团队成员各自维护自己的代码片段而互相不受影响。</li>
<li>解耦合可以使延迟绑定变得更加容易。延迟绑定，或者运行时绑定，是我们在运行时做决定而不是编译时，这在特定场合下很有用。</li>
</ul>
<p>这么说可能不够直观，没关系，我们只要知道解耦合能够给我们带来不少好处，至于具体如何体现的，我们后面会慢慢讲。</p>
<p>我们首先会看下紧耦合代码带来的一些问题，然后演示如何通过依赖注入来解耦合代码，以便于进一步的扩展和测试。最后还会介绍如何将 Ninject 容器应用到我们的程序中。</p>
<p>另外，当我们演示代码时，还会涉及 SOLID 原则相关的部分内容。SOLID 原则包括了个五个编码设计原则，它能够帮助我们设计出更易维护的代码。但本文的主题是依赖注入，对 SOLID 原则的部分内容只简单带过，如果想深入了解和学习，可以自行搜索相关资料。</p>
<p>依赖注入的实现方式有很多种，为了缩短篇幅，我将只挑选其中最常用的模式来讲解，构造函数注入。但是要知道，如果实际的应用场景不太一样，还有其他的一些模式可以选择。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>由于设计模式的部分概念过于抽象，单纯用文字想解释清楚也比较困难。所以，这里准备了一个应用程序，后面的内容都将围绕这个应用程序进行讲解，这个程序看起来很简单，实际又有些复杂。</p>
<p><img src="SimpleAPP.png" alt="No Images :("><br>说它简单是因为这个程序只有一个窗口。它从 Web 服务读取数据，然后显示在列表中，这就完了。通常我们不会在这么小规模的应用中使用依赖注入。因为它并不值得，为了代码的解耦而增加了程序的复杂性。</p>
<p>但是如果给你们展示一个真实的应用，又容易迷失在应用程序架构，模块交互，业务处理，以及其他许多方面的事情。<br>因此，我们将使用一个单窗体的应用以便于我们能够将注意力放在依赖注入的概念上。</p>
<p><img src="ComplexAPP.png" alt="No Images :("><br>说它复杂是因为这个单窗体的应用被分割成了多个层级。通常，我们不会对一个单窗体应用这么分层。但是，这同样有助于我们关注依赖注入本身，以及我们将看到依赖注入是如何帮助我们在大型应用中解决问题的。</p>
<p>这个应用程序分为四层：</p>
<ul>
<li>视图层，应用的界面。它由用户界面，控件比如按钮，列表等组成。</li>
<li>表现层，处理 UI 的逻辑部分。它包含了按钮事件调用的函数，UI 界面列表绑定的存储数据的对象。</li>
<li>数据访问层，负责与数据仓库的交互代码。示例的开始，我们从 Web 服务获取数据。数据访问层知道如何发起一个 Web 服务调用，然后将数据存储到对象中，以便应用的其他模块可以方便的使用。</li>
<li>数据仓库，获取实际数据的地方。</li>
</ul>
<p>整个应用程序的代码结构可以参考下图：</p>
<p><img src="TightCouplingSolutionExplorer01.png" alt="No Images :("></p>
<p>下面贴上主要部分的代码：</p>
<details>
<summary>PeopleViewerWindow.xaml.cs</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> PeopleViewer.Presentation;</span><br><span class="line"><span class="keyword">using</span> System.Windows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PeopleViewer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">PeopleViewerWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PeopleViewerWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line"></span><br><span class="line">            DataContext = <span class="keyword">new</span> PeopleViewModel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<details>
<summary>PeopleViewModel.cs</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Common;</span><br><span class="line"><span class="keyword">using</span> PersonRepository.Service;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PeopleViewer.Presentation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PeopleViewModel</span> : <span class="title">INotifyPropertyChanged</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">protected</span> ServiceReader Repository;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PeopleViewModel</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Repository = <span class="keyword">new</span> ServiceReader();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> IEnumerable&lt;Person&gt; _people;</span><br><span class="line">        <span class="keyword">public</span> IEnumerable&lt;Person&gt; People</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> _people; &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_people == <span class="keyword">value</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                _people = <span class="keyword">value</span>;</span><br><span class="line">                RaisePropertyChanged(<span class="string">&quot;People&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> _repositoryType = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> RepositoryType</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> _repositoryType; &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_repositoryType == <span class="keyword">value</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                _repositoryType = <span class="keyword">value</span>;</span><br><span class="line">                RaisePropertyChanged(<span class="string">&quot;RepositoryType&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> RefreshCommand Standard Stuff</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> RefreshCommand _refreshPeopleCommand = <span class="keyword">new</span> RefreshCommand();</span><br><span class="line">        <span class="keyword">public</span> RefreshCommand RefreshPeopleCommand</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_refreshPeopleCommand.ViewModel == <span class="literal">null</span>)</span><br><span class="line">                    _refreshPeopleCommand.ViewModel = <span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">return</span> _refreshPeopleCommand;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RefreshCommand</span> : <span class="title">ICommand</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> PeopleViewModel ViewModel &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CanExecuteChanged;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanExecute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endregion</span> RefreshCommand Standard Stuff</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                ViewModel.People = ViewModel.Repository.GetPeople();</span><br><span class="line">                ViewModel.RepositoryType = ViewModel.Repository.ToString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> ClearCommand Standard Stuff</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ClearCommand _clearPeopleCommand = <span class="keyword">new</span> ClearCommand();</span><br><span class="line">        <span class="keyword">public</span> ClearCommand ClearPeopleCommand</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_clearPeopleCommand.ViewModel == <span class="literal">null</span>)</span><br><span class="line">                    _clearPeopleCommand.ViewModel = <span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">return</span> _clearPeopleCommand;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClearCommand</span> : <span class="title">ICommand</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> PeopleViewModel ViewModel &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CanExecuteChanged;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanExecute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                ViewModel.People = <span class="keyword">new</span> List&lt;Person&gt;();</span><br><span class="line">                ViewModel.RepositoryType = <span class="built_in">string</span>.Empty;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> INotifyPropertyChanged Members</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RaisePropertyChanged</span>(<span class="params"><span class="built_in">string</span> propertyName</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> handler = PropertyChanged;</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>)</span><br><span class="line">                handler(<span class="keyword">this</span>, <span class="keyword">new</span> PropertyChangedEventArgs(propertyName));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<details>
<summary>ServiceReader.cs</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">using</span> Common;</span><br><span class="line">    <span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line">    <span class="keyword">using</span> System;</span><br><span class="line">    <span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line">    <span class="keyword">using</span> System.Net;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">PersonRepository.Service</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceReader</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> IEnumerable&lt;Person&gt; <span class="title">GetPeople</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                WebClient client = <span class="keyword">new</span> WebClient();</span><br><span class="line">                <span class="keyword">var</span> baseUrl = <span class="string">&quot;http://localhost:5001/api/people/&quot;</span>;</span><br><span class="line">                <span class="keyword">var</span> result = client.DownloadString(baseUrl);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> DeserializeObject(result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> IEnumerable&lt;Person&gt; <span class="title">DeserializeObject</span>(<span class="params"><span class="built_in">string</span> result</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">return</span> JsonConvert.DeserializeObject&lt;IEnumerable&lt;Person&gt;&gt;(result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Person <span class="title">GetPerson</span>(<span class="params"><span class="built_in">string</span> lastName</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;Person.cs&lt;/summary&gt;</span><br><span class="line">&lt;pre&gt;&lt;code&gt;</span><br><span class="line"></span><br><span class="line">```CS</span><br><span class="line">    <span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Common</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> DateTime StartDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> Rating &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>提供 Web 服务相关的代码没有放上来，因为不影响我们讲解的内容，我们只需要知道示例程序中访问的 Web API 的 Url，就像我们知道文件系统某个目录下有个 CSV 文件，能够给我们提供一些 Person 数据，这就够了。</p>
<h2 id="什么是紧耦合"><a href="#什么是紧耦合" class="headerlink" title="什么是紧耦合"></a>什么是紧耦合</h2><p>粗略一看，我们的应用程序代码似乎挺好的。代码有合理地分层，每个层级负责特定的任务。UI 相关的任务都在视图层，获取数据相关的任务都在数据访问层。</p>
<p><img src="AppLayers.png" alt="No Images :("></p>
<p>但是我们的应用程序还是存在着一个问题：紧耦合。</p>
<p>尽管每个代码层级负责不同的任务，但是每个层级还是干了一些不属于它职责范围的操作，这就导致了紧耦合。</p>
<p>让我们回到这个应用程序再看一下。</p>
<p>类 PeopleViewerWindow 在视图层，包含了 UI 控件。但是我们看下它的构造函数会发现，在视图层， PeopleViewerWindow 正在实例化一个 PeopleViewModel 对象。当我们在代码中实例化一个对象，耦合就产生了。</p>
<details>
<summary>PeopleViewerWindow's Constructor</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">PeopleViewerWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PeopleViewerWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        DataContext = <span class="keyword">new</span> PeopleViewModel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>首先，我们需要在编译时引用那个对象。如果我们不在编译时引用，毫无疑问，编译器没法成功编译我们的代码。另外，无论何时我们实例化一个对象，我们就得负责这个对象的生命周期。这样的结果就是，PeopleViewerWindow 和 PeopleViewModel 在表现层紧紧地耦合在了一起。</p>
<p><img src="TightCouplingViewViewModel.png" alt="No Images :("></p>
<p>我们继续往下看，还会发现同样的问题。</p>
<p>类 PeopleViewModel 负责表现层的逻辑。<br>在它的构造函数中，我们实例化了一个数据访问对象 ServiceReader。</p>
<details>
<summary>PeopleViewModel's Constructor</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PeopleViewModel</span> : <span class="title">INotifyPropertyChanged</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> ServiceReader Repository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PeopleViewModel</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Repository = <span class="keyword">new</span> ServiceReader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>正如我们刚刚提到的，我们对 ServiceReader 程序集产生了编译时的引用，我们就得负责这个对象的生命周期。</p>
<p>特别是，PeopleViewModel 在选择用什么技术来获取数据。通过实例化出 ServiceReader，PeopleViewModel 决定了数据来自 Web 服务。这样的结果就是位于表现层的 PeopleViewModel 和位于数据访问层的 ServiceReader 紧紧地耦合了。</p>
<p><img src="TightCouplingViewModelDataAccessor.png" alt="No Images :("></p>
<p>更糟糕地是，在类 ServiceReader 的方法 GetPeople 中，它实例化了一个 WebClient 对象，来获取实际的 Web 服务。</p>
<details>
<summary>ServiceReader's GetPeople</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceReader</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;Person&gt; <span class="title">GetPeople</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        WebClient client = <span class="keyword">new</span> WebClient();</span><br><span class="line">        <span class="keyword">var</span> baseUrl = <span class="string">&quot;http://localhost:5001/api/people/&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> result = client.DownloadString(baseUrl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DeserializeObject(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>


<p>这意味着我们在编译时引用了 WebClient，我们就得负责这个对象的生命周期。当我们想要在应用中多个地方共享同一个 WebClient 时，这尤其会成为一个问题。结果就是数据访问层紧紧地耦合了数据源。</p>
<p><img src="TightCouplingDataAccessorDataSource.png" alt="No Images :("></p>
<p>数据访问层通常需要知道数据源相关的一些信息，这里的耦合还不是那么严重。然而，这影响了应用程序整体的耦合度。因为视图层耦合着表现层，表现层耦合着数据访问层，数据访问层耦合着数据源，这意味着视图层耦合着数据源。</p>
<p><img src="TightCouplingViewDataSource.png" alt="No Images :("></p>
<p>可能有人会问，对于这么简单的一个应用程序来说，代码耦合有关系吗？答案是有关系！因为我们的应用程序开发并没有结束，还会有新的需求，我们往下看。</p>
<h2 id="紧耦合是如何影响我们的代码的"><a href="#紧耦合是如何影响我们的代码的" class="headerlink" title="紧耦合是如何影响我们的代码的"></a>紧耦合是如何影响我们的代码的</h2><p>刚开始，当我们把这个应用演示给客户的时候，他们会说，emm，不错，这就是我们想要的功能：读取数据，并且按照我们的需求显示出来。</p>
<p><img src="GoodButMoreRequirements.png" alt="No Images :("></p>
<p>但是，这还不够。</p>
<p>首先，客户希望程序可以连接不同的数据源。应用程序从 Web 服务获取数据没有问题，但是并不是所有的客户端都使用 Web 服务。部分客户端使用逗号分隔的文本文件，比如 CSV，部分使用 SQL 数据库，部分使用文件数据库，他们还希望客户端能够支持云服务甚至 Azure 功能。</p>
<p><img src="RequestDataSource.png" alt="No Images :("></p>
<p>OK，我们想了一下，应该没什么问题。这表示我们需要在实例化 ServiceReader 的地方做一些修改。最懒惰的方法就是可以增加 switch 声明，PeopleViewModel 可以实例化 ServiceReader，CSVReader，SQLReader。</p>
<p><img src="UsingSwitchGetDataSource.png" alt="No Images :("></p>
<p>代码看起来比较挫，但是他能实现我们的功能，所以让我们接着往下看。</p>
<p><img src="RequestClientCaching.png" alt="No Images :("></p>
<p>客户又有更多需求：在客户端要支持缓存。</p>
<p>在我们的应用中，数据访问层和数据源之间的通信通常花费了大部分的时间。因为我们通常通过网络发送信息，这受到网络延迟和带宽的限制。因为这个过程很耗时，所以支持客户端的缓存是很有必要的。所以我们需要一份数据的本地备份，从而不需要总是通过网络请求就可以重用数据。另外，客户还要求：缓存应当是可选的。<br>于是，我们继续扩展 switch 声明来支持带缓存或者不带缓存的各种 DataReader。</p>
<p><img src="UsingSwitchForCaching.png" alt="No Images :("></p>
<p>到这里，应该感觉到代码有些问题了，问题出在哪呢？我们来看。<br>问题在于，这部分代码违反了 SOLID 原则中的 S，也就是单一职责原则（Single Responsibility Principle）。</p>
<p>单一职责原则告诉我们，对象应当只有一个原因去作出变更。但是我们的 PeopleViewModel 有多个职责。主要的职责是表现层逻辑，但是它还负责为应用程序选择数据源，以及负责这些数据源的生命周期。现在，它还要决定我们是否使用缓存。毫无疑问，这肯定包含了太多的职责，这也是为什么代码会变得越来越难维护。</p>
<p>不仅如此，客户还要求有单元测试。</p>
<p>单元测试能够帮助我们节约很多编码时间。如果我们尝试为表现层的 PeopleViewModel 写单元测试，就需要实例化 PeopleViewModel 对象。但是在 PeopleViewModel 的构造函数中，我们实例化了 ServiceReader，而 ServiceReader 实例化了连接 Web 服务的 WebClient 对象。意味着测试想要正常工作，Web 服务就需要保持运行。</p>
<p><img src="UnitTestWithLotsOfDependency.png" alt="No Images :("></p>
<p>这显然是不现实的，我们需要应用程序有更好的独立性，以便测试更加可靠和可重复。我们可以在测试中使用反射来改变 ServiceReader，但是这么做的结果是测试代码变得复杂以及难以维护，而我们希望单元测试应该有简单可读的代码，这样我们才会更愿意去使用它们。</p>
<p>在我们继续之前，我们再整理下客户的需求：</p>
<ul>
<li>使用不同的数据源</li>
<li>增加客户端缓存，并且是可选的</li>
<li>包含单元测试</li>
</ul>
<p>上面说的方案显然是不可取的，那么我们怎么样才能避免产出紧耦合的代码呢？这就引出了本文的主题，我们继续往下看。</p>
<h2 id="使用依赖注入解耦合应用"><a href="#使用依赖注入解耦合应用" class="headerlink" title="使用依赖注入解耦合应用"></a>使用依赖注入解耦合应用</h2><p>到这里，我们的主角终于可以上场了。</p>
<p><img src="InsertDI01.png" alt="No Images :("></p>
<p>下面，我们就使用依赖注入进行代码解耦合。</p>
<p>首先，我们给代码添加一层抽象。然后，我们会使用依赖注入中的一种模式——构造函数注入，来创建解耦合的代码。<br>在之前我们设想的方案中，问题主要出在类 PeopleViewModel 上，也就是应用的表现层，尤其是类 PeopleViewModel 的构造函数，实例化类 ServiceReader 的地方。</p>
<p><img src="BreakTightCoupling.png" alt="No Images :("></p>
<p>因此，我们将关注于类 PeopleViewModel 和 ServiceReader 的解耦。如果我们解耦成功，我们就能够更容易地满足用户的需求。</p>
<p>所以，总体来讲，解耦可以分为三步：</p>
<ul>
<li>添加一个接口，一个抽象层，增加代码灵活性</li>
<li>在应用程序代码中加入构造函数注入</li>
<li>将解耦的各个模块组合到一起</li>
</ul>
<p>首先第一步，我们需要思考下如何才能够让我们的应用程序连接不同的数据源。</p>
<p><img src="DifferentDataSource.png" alt="No Images :("></p>
<p>这里直接引入 Repository 模式。</p>
<p>Repository 模式作为应用程序对象和数据获取模块的媒介，使用类似集合的接口来获取应用程序对象。它将应用程序从特定的数据存储技术分割了出来。</p>
<p><img src="UsingRepository01.png" alt="No Images :("></p>
<p>Repository 的思想是知道如何和数据源沟通，不管是 HTTP，文件系统上的文档，还是数据库访问。在获得这些数据之后，将其转换成应用程序其他模块可以使用的 C# 对象。</p>
<p>emm，这不就是 ServiceReader 现在干的事情嘛。它对 Web 服务发起了一个 HTTP 请求，然后将 JSON 格式的结果转换成应用程序可以理解的 People 类对象。但是问题在于表现层的 PeopleViewModel 与数据访问层的 ServiceReader 直接进行了交互。</p>
<p>为了我们的应用更加地灵活，我们给 Repository 加上接口，所有在表现层的通信都将通过这个接口实现。</p>
<p>这符合 SOLID 原则中的 D，也就是依赖倒置原则（Dependency Inversion Principle）。依赖倒置原则中的一点是，上层的模块不应该依赖于下层的模块，应该都依赖于接口。</p>
<p>有了抽象，表现层就可以很容易的与 CSV 或者 SQL Repository 通信了。</p>
<p><img src="RepositoryAddingInterface.png" alt="No Images :("></p>
<p>很多时候，我们使用的 Repository 是 CRUD Repository，CRUD 代表 create, read, update, 以及 delete。<br>然而，我们不需要所有这些操作。SOLID 原则中 I，也就是接口分离原则（Interface Segregation Principle）告诉我们，接口应该只包含需要的功能。<br>一个完整的 Repository 通常有读写的操作，但是我们的应用程序中，类 PeopleViewModel 只需要读操作。<br>因此为了符合接口分离原则，我们的接口应该也只支持读操作。</p>
<p>基于此，我们将创建一个数据读取接口，IPersonReader。接口包含了一个 GetPeople 函数，返回所有的 Person 对象，还有一个 GetPerson 方法检索单个人的信息。</p>
<details>
<summary>IPersonReader</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Common</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPersonReader</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">IEnumerable&lt;Person&gt; <span class="title">GetPeople</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Person <span class="title">GetPerson</span>(<span class="params"><span class="built_in">string</span> lastName</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>


<p>让我们在代码里加上这个接口，以对 PeopleViewModel 和 ServiceReader 进行解耦。<br>类 ServiceReader 有两个方法 GetPeople 和 GetPerson。这也是我们在接口中需要的两个方法。<br>所以我们新建接口 IPersonReader，并且让 ServiceReader 继承它。</p>
<details>
<summary>ServiceReader</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PersonRepository.Service</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceReader</span> : <span class="title">IPersonReader</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerable&lt;Person&gt; <span class="title">GetPeople</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            ...            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">GetPerson</span>(<span class="params"><span class="built_in">string</span> lastName</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>我们回到表现层的 PeopleViewModel，将成员变量 ServiceReader 改为 IPersonReader。这只是解耦的一小部分，我们需要的是避免在构造函数中实例化 ServiceReader。</p>
<p>所以，下面我们准备解耦表现层的 PeopleViewModel 和 数据访问层的 ServiceReader。<br>解耦的方式是，通过构造函数，注入 ServiceReader 到 PeopleViewModel， 注入 PeopleViewModel 到 PeopleViewerWindow，然后再将这些对象组合在一起。</p>
<p>我们来看下，在 PeopleViewModel 中的构造函数中，我们不希望实例化 ServiceReader。因为选取数据源不是 PeopleViewModel 的职责。<br>所以我们给构造函数添加一个参数，通过这个参数我们将 ServiceReader 对象传递给 PeopleViewModel 的成员变量 IPersonReader。</p>
<p>这个添加构造函数参数的简单操作，其实就实现了依赖注入。</p>
<details>
<summary>PeopleViewModel</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PeopleViewer.Presentation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PeopleViewModel</span> : <span class="title">INotifyPropertyChanged</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">protected</span> IPersonReader DataReader;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PeopleViewModel</span>(<span class="params">IPersonReader reader</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DataReader = reader;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>我们没有消除依赖，PeopleViewModel 仍然依赖于 IPersonReader，我们通过这个接口调用 GetPeople。<br>但是 PeopleViewModel 不再需要管理依赖对象，我们通过构造函数注入依赖，这就是为什么这个模式叫做构造函数注入。</p>
<p>这个时候如果我们编译程序会发现，PeopleViewerWindow 的代码出错了，因为它想要实例化一个无参的 PeopleViewModel 构造函数。我们可以在 PeopleViewerWindow 中实例化 ServiceReader，但是实例化 ServiceReader 不是 PeopleViewModel 的职责，所以更加不是 PeopleViewerWindow 的职责。</p>
<p>那么怎么解决呢？<br>我们把这个问题丢出去，不管谁创建了 PeopleViewModel，都应该负责创建一个 ServiceReader。所以我们仍然用构造函数将 PeopleViewModel 注入到 PeopleViewerWindow。</p>
<details>
<summary>PeopleViewerWindow</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PeopleViewer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">PeopleViewerWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PeopleViewerWindow</span>(<span class="params">PeopleViewModel viewModel</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            DataContext = viewModel;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>有件事注意一下，这里我们没有给 PeopleViewModel 创建接口，通常我们只在需要的时候添加接口，因为接口增加了一层复杂性以及对代码进行了重定向。以我们一贯的经验来看，View 和 ViewModel 之间的关系大多是一对一或者多对一的，因此我们不介意在这有具体类的耦合。<br>如果我确实需要将多个 PeopleViewModel 绑定到同一个 PeopleViewerWindow，那么我会先添加一个接口。</p>
<p>接下来，我们需要将各个解耦合的模块组合起来，我们打开 App.xaml.cs 文件，在 OnSratup 方法中实例化 PeopleViewerWindow，由于 PeopleViewerWindow 的构造函数需要一个 PeopleViewModel 的对象，所以我们需要首先实例化 PeopleViewModel，而 PeopleViewModel 的构造函数需要一个 IPersonReader 类型的对象，所以我们还得先实例化一个 ServiceReader 对象并注入到 PeopleViewModel 的构造函数。</p>
<details>
<summary>App.OnStartup</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PeopleViewer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Interaction logic for App.xaml</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">App</span> : <span class="title">Application</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStartup</span>(<span class="params">StartupEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnStartup(e);</span><br><span class="line"></span><br><span class="line">            ComposeObjects();</span><br><span class="line">            Application.Current.MainWindow.Show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ComposeObjects</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> repository = <span class="keyword">new</span> ServiceReader();</span><br><span class="line">            <span class="keyword">var</span> viewModel = <span class="keyword">new</span> PeopleViewModel(repository);</span><br><span class="line">            Application.Current.MainWindow = <span class="keyword">new</span> PeopleViewerWindow(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>这里我们在做的就是把各个解耦的片段组合起来。运行程序后，和之前一样，从 web 服务读取的数据显示在界面上了。</p>
<p><img src="AppConnect2WebServiceWithDI.png" alt="No Images :("></p>
<p>我们看到，类 App 中的 OnStartup 扮演的是一个 Bootstrapper 的角色，负责启动应用程序，以及将不同模块的对象组合到一起。<br><img src="BootstrappterForDiffLayers.png" alt="No Images :("></p>
<p>现在 Bootstrapper 和 Viewer 在同一个工程，我们也可以把 Viewer 放到单独的一个工程，后面依赖注入容器的部分，我们会看到，我们可以使用不同的 Bootstrapper 来调用这个 Viewer 对象。</p>
<p>我们来回顾下这部分内容，我们对 PeopleViewModel 和 ServiceReader 通过构造函数注入进行解耦。</p>
<p><img src="ConstructorDI.png" alt="No Images :("></p>
<p>我们给构造函数增加了一个参数，同时增加了依赖注入，而不是在内部处理依赖。类 PeopleViewModel 依赖 IPersonReader，因为需要调用接口 IPersonReader 的 GetPeople 方法。<br>我们没有消除依赖，我们只是控制了怎么处理依赖，通过添加构造函数注入，我们把处理依赖的部分丢给了 Bootstrapper 模块，这就是依赖注入实现的方式。</p>
<p>PeopleViewModel 不再负责依赖对象的生命周期管理，而只是使用依赖对象。由此，我们解耦合了表现层的 PeopleViewModel 和数据访问层的 ServiceReader。这给了我们进一步开发的灵活性。</p>
<p>在上一节，我们看到了第一个版本的代码违反了 SOLID 原则中的 S，单一职责原则。<br><img src="ViolationSRP.png" alt="No Images :("></p>
<p>而更新的代码中，PeopleViewModel 不再通过实例化 ServiceReader 来选择数据源，不再负责 ServiceReader 的生命周期，也不再决定是否使用客户端缓存。</p>
<p><img src="FollowSRP.png" alt="No Images :("></p>
<p>PeopleViewModel 现在只负责表现层的逻辑，提供 UI 能够调用的方法和绑定的数据，这就做到了职责单一。</p>
<h2 id="解耦合代码解决的问题"><a href="#解耦合代码解决的问题" class="headerlink" title="解耦合代码解决的问题"></a>解耦合代码解决的问题</h2><p>在之前的内容中，我们花了不少时间在应用程序中加入依赖注入。我们通过构造函数注入依赖，然后在启动应用的 Bootstrapper 中将不同模块的对象组合起来。</p>
<p>现在代码已经解耦了，那么，这给我们带来了什么好处？</p>
<p>后面的内容，我们可以看到，通过替换程序中 ServiceReader，可以从不同的数据源获取数据，我们可以从文本文件中获取数据，也可以从数据库中获取数据。</p>
<p>我们还可以给程序增加一个客户端缓存，在应用程序的内存中保存数据，以避免我们每次请求都访问数据源。</p>
<p>我们可以很容易的给程序添加简洁的单元测试代码。</p>
<p>这也是我们之前看过的三个需求，并且我们也会看到代码的实现方式都遵循了 SOLID 原则。</p>
<p>我们先来看第一个需求，替换不同的数据源。</p>
<p><img src="RequestDataSource.png" alt="No Images :("></p>
<p>我们以读取 CSV 文件的数据为例子，要从 CSV 文件获取数据，我们将增加一个 CSV 文件的 DataReader， 然后把它加到程序里。</p>
<p>我们添加一个 PersonDataReader.CSV 工程，其中，类 CSVReader 有我们需要的功能。</p>
<details>
<summary>CSVReader</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PersonRepository.CSV</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CSVReader</span> : <span class="title">IPersonReader</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> _csvFilename;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CSVReader</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _csvFilename = AppDomain.CurrentDomain.BaseDirectory + <span class="string">&quot;Resources\\People.csv&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerable&lt;Person&gt; <span class="title">GetPeople</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> people = <span class="keyword">new</span> List&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (File.Exists(_csvFilename))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> sr = <span class="keyword">new</span> StreamReader(_csvFilename))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> line;</span><br><span class="line">                    <span class="keyword">while</span> ((line = sr.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> elems = line.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">                        <span class="keyword">var</span> per = <span class="keyword">new</span> Person()</span><br><span class="line">                        &#123;</span><br><span class="line">                            FirstName = elems[<span class="number">0</span>],</span><br><span class="line">                            LastName = elems[<span class="number">1</span>],</span><br><span class="line">                            StartDate = DateTime.Parse(elems[<span class="number">2</span>]),</span><br><span class="line">                            Rating = Int32.Parse(elems[<span class="number">3</span>])</span><br><span class="line">                        &#125;;</span><br><span class="line">                        people.Add(per);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> people;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">GetPerson</span>(<span class="params"><span class="built_in">string</span> lastName</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Person selPerson = <span class="keyword">new</span> Person();</span><br><span class="line">            <span class="keyword">if</span> (File.Exists(_csvFilename))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> sr = <span class="keyword">new</span> StreamReader(_csvFilename);</span><br><span class="line">                <span class="built_in">string</span> line;</span><br><span class="line">                <span class="keyword">while</span> ((line = sr.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> elems = line.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (elems[<span class="number">1</span>].ToLower() == lastName.ToLower())</span><br><span class="line">                    &#123;</span><br><span class="line">                        selPerson.FirstName = elems[<span class="number">0</span>];</span><br><span class="line">                        selPerson.LastName = elems[<span class="number">1</span>];</span><br><span class="line">                        selPerson.StartDate = DateTime.Parse(elems[<span class="number">2</span>]);</span><br><span class="line">                        selPerson.Rating = Int32.Parse(elems[<span class="number">3</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> selPerson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>首先，CSVReader 实现了 IPersonReader 接口，因此我们的 PeopleViewModel 能够像使用 ServiceReader 一样使用 CSVReader。<br>方法 GetPeople 使用 StreamReader 从文件系统加载文件，一旦数据返回，它就将数据解析到 Person 对象。</p>
<p>然后，我们需要重新组合应用程序模块，用 CSVReader 替换 ServiceReader。<br>所以我们重新回到 bootstrapper 工程的类 App，引用 PersonDataReader.CSV 工程。然后在 OnStartup 函数中实例化一个 CSVReader 来替代 ServiceReader，只有一行代码的改动，是不是很简单。</p>
<details>
<summary>App.OnStartup</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PeopleViewer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Interaction logic for App.xaml</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">App</span> : <span class="title">Application</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStartup</span>(<span class="params">StartupEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnStartup(e);</span><br><span class="line"></span><br><span class="line">            ComposeObjects();</span><br><span class="line">            Application.Current.MainWindow.Show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ComposeObjects</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> repository = <span class="keyword">new</span> CSVReader();</span><br><span class="line">            <span class="keyword">var</span> viewModel = <span class="keyword">new</span> PeopleViewModel(repository);</span><br><span class="line">            Application.Current.MainWindow = <span class="keyword">new</span> MainWindow(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>我们重新运行我们的应用，点击 Fetch People 按钮，我们从 CSV 文件获取到了数据。</p>
<p>我们看到，我们不需要修改程序中的 PeopleViewModel 类，不需要修改 PeopleViewerWindow 类，也不需要修改 ServiceReader 类，就替换了程序的数据源。</p>
<p><img src="OpenCloseProposal.png" alt="No Images :("></p>
<p>这符合 SOLID 原则中的 O，也就是开闭原则（Open-Closed Principle）。开闭原则要求我们现有的代码应当面向扩展开放，而面向修改封闭。</p>
<p>我们接着再来看第二个需求，增加客户端缓存。</p>
<p><img src="AddCaching.png" alt="No Images :("></p>
<p>我们可以在 CSVReader 或者 ServiceReader 中直接增加数据缓存的代码，但是现在我们的代码已经解耦合了，我们有更好的方式去实现这个功能，这里我们引入 Decorator 模式。</p>
<p>那么什么是 Decorator 模式？ Decorator 模式是一种通过包装现有接口来增加功能的模式。</p>
<p>根据我们的需求翻译下就是，包装实现了接口 IPersonReader 的 ServiceReader 或者 CSVReader，来增加数据缓存功能。</p>
<p><img src="WrapReader.png" alt="No Images :("></p>
<p>我们先导入 PersonRepository.Caching 工程，暂时先不管 CachingReader 的代码实现，我们先看看现有的代码需要做哪些修改。 </p>
<p>我们以 ServiceReader 为例，ServiceReader 实现了 IPersonReader 接口。我们获取 ServiceReader， 并将它包装在一个 CachingReader 里。这样就增加了我们需要的数据缓存功能。</p>
<details>
<summary>App.OnStartup</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PeopleViewer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Interaction logic for App.xaml</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">App</span> : <span class="title">Application</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStartup</span>(<span class="params">StartupEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnStartup(e);</span><br><span class="line"></span><br><span class="line">            ComposeObjects();</span><br><span class="line">            Application.Current.MainWindow.Show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ComposeObjects</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> repository = <span class="keyword">new</span> CSVReader();</span><br><span class="line">            <span class="keyword">var</span> wrappedRepository = <span class="keyword">new</span> CachingReader(repository);</span><br><span class="line">            <span class="keyword">var</span> viewModel = <span class="keyword">new</span> PeopleViewModel(wrappedRepository);</span><br><span class="line">            Application.Current.MainWindow = <span class="keyword">new</span> MainWindow(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>完了吗？完了！就这么简单。</p>
<p>我们重新运行下程序，确保 Web 服务运行，然后 Fetch People，得到了数据。我们再把 Web 服务关掉，清空数据，重新 Fetch People，依然能够获得数据，我们的缓存时间设置了15秒，所以我们等缓存时间到了，重新 Fetch People，数据没有了，如果我们重新启动 Web 服务，重新 Fetch People，会发现数据又恢复了。</p>
<p>现在让我们来看下 CachingReader 类的实现。</p>
<details>
<summary>CachingReader</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PersonRepository.Caching</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CachingReader</span> : <span class="title">IPersonReader</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> TimeSpan _cacheDuration = <span class="keyword">new</span> TimeSpan(<span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">private</span> DateTime _dataDateTime;</span><br><span class="line">        <span class="keyword">private</span> IPersonReader _wrappedRepository;</span><br><span class="line">        <span class="keyword">private</span> IEnumerable&lt;Person&gt; _cachedItems;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CachingReader</span>(<span class="params">IPersonReader wrappedPersonRepository</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _wrappedRepository = wrappedPersonRepository;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerable&lt;Person&gt; <span class="title">GetPeople</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            ValidateCache();</span><br><span class="line">            <span class="keyword">return</span> _cachedItems;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">GetPerson</span>(<span class="params"><span class="built_in">string</span> lastName</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            ValidateCache();</span><br><span class="line">            <span class="keyword">return</span> _cachedItems.FirstOrDefault(p =&gt; p.LastName == lastName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">bool</span> IsCacheValid</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> _cacheAge = DateTime.Now - _dataDateTime;</span><br><span class="line">                <span class="keyword">return</span> _cacheAge &lt; _cacheDuration;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ValidateCache</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_cachedItems == <span class="literal">null</span> || !IsCacheValid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    _cachedItems = _wrappedRepository.GetPeople();</span><br><span class="line">                    _dataDateTime = DateTime.Now;</span><br><span class="line">                &#125;</span><br><span class="line">                catch</span><br><span class="line">                &#123;</span><br><span class="line">                    _cachedItems = <span class="keyword">new</span> List&lt;Person&gt;()</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">new</span> Person()&#123; FirstName=<span class="string">&quot;No Data Available&quot;</span>, LastName = <span class="built_in">string</span>.Empty, Rating = <span class="number">0</span>, StartDate = DateTime.Today&#125;,</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InvalidateCache</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _dataDateTime = DateTime.MinValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>CachingReader 同样是个 IPersonReader，所以对应用的其他部分来说，CachingReader 与 ServiceReader 或者 CSVReader 没有什么区别。</p>
<p><img src="LiskovSubstitutionProposal.png" alt="No Images :("></p>
<p>这符合 SOLID 原则中的 L，也就是李氏替换原则（Liskov Substitution Principle）。任何基类可以出现的地方，子类一定可以出现。</p>
<p>通过使用 Decorator 模式，我们能够包装任何一个现有的 DataReader。我们在 CachingReader 上同样使用构造函数，来注入真正的 DataReader。</p>
<p>我们有一个私有成员变量 _wrappedReader，和一个 IPersonReader 类型变量，这是我们想要包装并添加缓存功能的真正的 DataReader。</p>
<p>其他类成员用来控制缓存。TimeSpan 类型的 cacheDuration 对象用来判断缓存在内存中保留的时间，这里我们设置了15秒，但是我们可以通过配置文件来修改它。其他两个变量和缓存本身有关，cacheDuration 变量是一个 Person 类型的 IEnumerable 对象，这就是我们内存中的缓存，dataDateTime 变量包含了缓存更新的上一次时间，因此我们能够通过这个变量来判断我们的缓存是否有效或者过期。</p>
<p>如果我们看下 GetPeople 方法，会发现有两个处理步骤。<br>第一个是验证缓存。如果缓存过期或者没有缓存，它就会通过包装的 reader 来获取数据，并且保存到 cachedItems 中。如果缓存有效， 那么就直接使用缓存。这只是简单的客户端缓存实现方式。</p>
<p><img src="ReComposeCaching.png" alt="No Images :("></p>
<p>我们也已经看到，通过 Decorator 模式增加缓存功能，只需要在 Bootstrapper 工程中简单地修改几行代码就能够实现，并且如果需要，我们也可以很容易地配置程序来启用或者禁用缓存功能。</p>
<h2 id="依赖注入为单元测试带来了什么"><a href="#依赖注入为单元测试带来了什么" class="headerlink" title="依赖注入为单元测试带来了什么"></a>依赖注入为单元测试带来了什么</h2><p>我们都知道，单元测试是用于测试独立的功能模块的。这里我们就来看下，怎么为 PeopleViewModel 模块做单元测试。</p>
<p>首先，我们需要测试 RefreshPeople 方法。当这个方法被调用时，我们期望 PeopleViewModel 的 People 属性被赋值了。<br>类似的，我们需要测试 ClearPeople 方法。当这个方法被调用时，我们期望 PeopleViewModel 的 People 属性被清空了。</p>
<p>回到我们添加依赖注入之前，我们了解了对紧耦合的代码做单元测试带来的问题。</p>
<p><img src="UnitTestWithLotsOfDependency.png" alt="No Images :("></p>
<p>由于代码的耦合度很高，单元测试会依赖于实际的生产数据。</p>
<p>但是，现在我们的代码是解耦合的，我们不需要依赖于实际数据源。这里，我们创建了一个模拟的数据访问接口 FakeReader，并且在方法 GetPeople 中返回一些测试数据。</p>
<details>
<summary>FakeReader</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PersonRepository.Fake</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FakeReader</span> : <span class="title">IPersonReader</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerable&lt;Person&gt; <span class="title">GetPeople</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Person&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> Person() &#123;FirstName = <span class="string">&quot;John&quot;</span>, LastName = <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">                    Rating = <span class="number">7</span>, StartDate = <span class="keyword">new</span> DateTime(<span class="number">2000</span>, <span class="number">10</span>, <span class="number">1</span>)&#125;,</span><br><span class="line">                <span class="keyword">new</span> Person() &#123;FirstName = <span class="string">&quot;Mary&quot;</span>, LastName = <span class="string">&quot;Thomas&quot;</span>,</span><br><span class="line">                    Rating = <span class="number">9</span>, StartDate = <span class="keyword">new</span> DateTime(<span class="number">1971</span>, <span class="number">7</span>, <span class="number">23</span>)&#125;,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">GetPerson</span>(<span class="params"><span class="built_in">string</span> lastName</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>然后我们看下测试代码。</p>
<details>
<summary>UnitTest</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PeopleViewer.Presentation.Tests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestClass</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PeopleViewModelTests</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">People_OnRefreshCommand_IsPopulated</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// Arrange</span></span><br><span class="line">            <span class="keyword">var</span> repository = <span class="keyword">new</span> FakeReader();</span><br><span class="line">            <span class="keyword">var</span> vm = <span class="keyword">new</span> PeopleViewModel(repository);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Act</span></span><br><span class="line">            vm.RefreshPeopleCommand.Execute(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Assert</span></span><br><span class="line">            Assert.IsNotNull(vm.People);</span><br><span class="line">            Assert.AreEqual(<span class="number">2</span>, vm.People.Count());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">People_OnClearCommand_IsEmpty</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// Arrange</span></span><br><span class="line">            <span class="keyword">var</span> repository = <span class="keyword">new</span> FakeReader();</span><br><span class="line">            <span class="keyword">var</span> vm = <span class="keyword">new</span> PeopleViewModel(repository);</span><br><span class="line">            vm.RefreshPeopleCommand.Execute(<span class="literal">null</span>);</span><br><span class="line">            Assert.AreEqual(<span class="number">2</span>, vm.People.Count(), <span class="string">&quot;Invalid Arrangement&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Act</span></span><br><span class="line">            vm.ClearPeopleCommand.Execute(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Assert</span></span><br><span class="line">            Assert.AreEqual(<span class="number">0</span>, vm.People.Count());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>我们发现 FakeReader 也是完全独立的，并不影响实际的数据访问逻辑，我们可以通过 PeopleViewModel 的构造函数注入 FakeReader 对象进行单元测试。这就给了我们对测试代码，数据源的完全控制。</p>
<p>并且，测试的代码只有几行，而易于阅读和编写的测试是能够鼓励程序员去使用它们的。</p>
<h2 id="依赖注入容器"><a href="#依赖注入容器" class="headerlink" title="依赖注入容器"></a>依赖注入容器</h2><p>到这里，我们已经基本了解了依赖注入的概念，并且在应用程序中通过依赖注入，我们解耦合了代码。我们也看到了依赖注入给我们带来的便利，包括但不仅限于易于扩展代码，易于单元测试。</p>
<p>在 .NET 的世界中，有很多流行的功能齐全的依赖注入容器，许多框架也都包含了依赖注入容器，比如 ASP.NET Core MVC。</p>
<p><img src="DIContainers.png" alt="No Images :("></p>
<p>我觉得依赖注入容器就像一个蒙面侠，为什么呢？<br>主要是因为当我刚接触依赖注入容器的代码时，就感觉像是隔着一层面具在观察陌生人，你想象不出他脸上遮住的部分，但是当我们看过了这个陌生人的脸后(了解了依赖注入的原理)，即使他重新戴回面具，我们依然能够想起他的长相。<br>这就是为什么一开始我们避开了容器来讲解依赖注入。</p>
<p>我们以 NinJect 为例进行讲解。我们会看到如何在程序中配置容器，管理对象生命周期，以及从容器中获得对象。<br>我们可以通过包管理平台 NuGet 下载 NinJect 包，并在项目中引用。</p>
<p>这里，我们将 Bootstrappter 部分的代码和 PeopleViewerWindow 分开放在了单独的工程里，以便 PeopleViewerWindow 可以被多个版本的 Bootstrappter调用。以下是更新后的工程目录：</p>
<p><img src="LooseCouplingSolutionExplorer01.png" alt="No Images :("></p>
<p>以下是涉及依赖注入容器的代码部分。</p>
<details>
<summary>App.OnStartup with NinJect</summary>
<pre><code>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Bootstrappter.Ninject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">App</span> : <span class="title">Application</span></span><br><span class="line">    &#123;</span><br><span class="line">        IKernel Container;</span><br><span class="line">        <span class="built_in">bool</span> IsCacheEnabled = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStartup</span>(<span class="params">StartupEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnStartup(e);</span><br><span class="line"></span><br><span class="line">            ConfigureContainer();</span><br><span class="line">            ComposeObjects();</span><br><span class="line"></span><br><span class="line">            Application.Current.MainWindow.Show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConfigureContainer</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Container = <span class="keyword">new</span> StandardKernel();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (IsCacheEnabled)</span><br><span class="line">            &#123;</span><br><span class="line">                Container.Bind&lt;IPersonReader&gt;().To&lt;CachingReader&gt;().InSingletonScope()</span><br><span class="line">                    .WithConstructorArgument&lt;IPersonReader&gt;(Container.Get&lt;CSVReader&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Container.Bind&lt;IPersonReader&gt;().To&lt;CSVReader&gt;().InSingletonScope();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ComposeObjects</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Application.Current.MainWindow = Container.Get&lt;PeopleViewerWindow&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></code></pre></p>
</details>

<p>在了解依赖注入原理之前，看到这段代码可能是比较痛苦的。在现在的上下文环境里，我们或许能够猜测，这跟我们之前手动组合模块的代码实现的功能是基本一样的。但是，我们发现，这里面见不到类 PeopleViewModel 的影子，可我们很清楚，不说功能，单从编译的角度来讲，实例化类 PeopleViewModel 是必须的，因为 PeopleViewerWindow 的构造函数需要一个 PeopleViewModel 对象。那么就只有一种可能，就是依赖注入容器内部实例化了 PeopleViewModel 对象并且传递给了 PeopleViewerWindow 的构造函数。</p>
<p>所以，我们看到，容器具有自动注册功能，它会为对象搜索依赖并归类，并且能够根据依赖关系将对象串联起来。<br>这使得我们的配置代码降到了最少，同时，也给了我们很大的灵活性。</p>
<p>当然，这也降低了效率，因此应用程序的启动时间变长了。所以我们在使用容器的时候要考虑，是否需要牺牲程序运行的效率来简化代码。</p>
<p>容器另一个特性是生命周期管理，当我们在看紧耦合的代码时，我们发现如果一个对象实例化一个依赖，那么它就得负责这个对象的生命周期。有了依赖注入容器，容器会负责生命周期。我们能够告诉容器如何管理生命周期，比如使用单例还是每次调用都使用新的实例。</p>
<p>我们还看到，通过变量 IsCacheEnabled 控制着应用程序是否支持缓存功能。想要更加的灵活，我们可以选择从配置文件读取变量 IsCacheEnabled 的值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相信看到这部分内容的，已经对依赖注入以及依赖注入容器有了基本的了解。本文只是依赖注入的入门讲解，重点介绍了如何通过构造函数来注入依赖。</p>
<p>我们看到，紧耦合的应用程序带来了许多问题，而解耦合给我们的代码带来了许多益处。不仅如此，我们还看到了我们的应用程序是怎么遵守 SOLID 原则的，以及 Decorator 模式在程序中的应用。</p>
<p>最后，再次强调，依赖注入是帮助我们开发解耦合代码的一系列软件设计原则和模式。解耦合代码是其中的关键，也是本文的中心，而依赖注入只是其中的一种解耦合方法。</p>
]]></content>
      <categories>
        <category>donet</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Design &amp; Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern C++ 中错误处理的最佳实践</title>
    <url>/2021/04/12/cplusplus/exception-handling/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Modern C++ 中，大多数情况下，<strong>异常</strong>都是处理程序错误的首选方式，这包括程序的逻辑错误和运行时错误。异常为包含错误的代码提供了一种标准且明确的手段，使错误信息能够在调用栈中向上层传递。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>程序错误通常分为两类：</p>
<ul>
<li>编码引入的逻辑错误，如 “index out of range”。</li>
<li>运行时错误，如 “network service unavailable”。</li>
</ul>
<p>在 C 风格代码或者 COM 中，错误的返回主要通过以下方式实现：</p>
<ul>
<li>返回错误码或者特定函数的状态码。例如在 COM 中，通过返回 <code>HRESULT</code>，从而将错误信息返回给调用代码。</li>
<li>设置一个全局变量用于保存错误信息。例如 Win32 API 有 <code>GetLastError</code> 函数来获取调用栈中最新的错误信息。</li>
</ul>
<p>以上两种情况，都是依赖于调用代码对错误进行处理。如果调用方没有处理错误代码，程序可能会在没有任何告警的情况下崩溃，或者继续使用错误的数据产生错误的结果。</p>
<p>在 Modern C++ 中，使用异常处理通常是更为推荐的做法，这有以下几点原因：</p>
<span id="more"></span>
<ul>
<li>异常强制保证了调用代码能够识别发生错误的条件并进行处理，未处理的异常会终止程序的运行。</li>
<li>异常发生时，代码可以跳转到能够处理异常的部分，异常可以在栈中传递，实现程序中异常产生部分和异常处理部分的分离。</li>
<li>异常的栈展开机制（stack-unwinding mechanism）会依照明确定义的规则，在异常抛出后销毁所有作用域内的对象。</li>
</ul>
<p>以下示例包含了抛出和捕获 C++ 异常的语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; numeric_limits&lt;<span class="keyword">char</span>&gt; ::<span class="built_in">max</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;MyFunc argument too large.&quot;</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MyFunc</span>(<span class="number">256</span>); <span class="comment">//cause an exception to throw</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (invalid_argument&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++ 中的异常和 C# 以及 Java 中的很像。在 <code>try</code> 块中，如果异常被抛出，他会被首个满足异常类型的 <code>catch</code> 块捕获，即，异常从 throw 表达式跳转到了 catch 表达式。如果没有满足条件的 catch 块，<code>std::terminate</code> 会被触发并且程序会退出。</p>
<p>在 C++ 中，任何类型都可以被抛出，然而，建议只抛出继承于 <code>std::exception</code> 类型的异常。上述示例中，异常类型 <code>invalid_argument</code> 是在头文件 <code>&lt;stdexcept&gt;</code> 包含的标准库中定义的。 </p>
<p>异常被抛出后，C++ 不提供(也不需要) <code>finally</code> 块来保证资源的释放。可以使用智能指针来管理资源的释放。</p>
<h2 id="异常处理的基本原则"><a href="#异常处理的基本原则" class="headerlink" title="异常处理的基本原则"></a>异常处理的基本原则</h2><p>如何设计完善的异常处理程序在任何编程语言中都是个挑战。尽管异常为代码中的错误处理提供了不少支持，不代表异常处理就是万能的，我们仍然需要合理的设计异常处理程序：</p>
<ul>
<li>使用断言来诊断不该发生的错误，而使用异常来处理可能发生的错误，如 <code>public</code> 函数的参数检验。</li>
<li>总是使用异常来检验 <code>public</code> 函数的参数。因为即使你的函数本身没有问题，你无法完全保证在任何参数下，它都一定正确。</li>
<li>当需要将包含错误的代码和处理错误的代码分离时，请使用异常。</li>
<li>在对性能要求较为严格的地方，权衡是否应该使用异常。</li>
<li>对于每个可能抛出或者传递异常的函数，满足 <em>the strong guarantee</em>, <em>the basic guarantee</em>, 或 <em>the nothrow (noexcept) guarantee</em> 中的一个。</li>
<li>抛出异常的时候使用值类型，捕获异常的时候使用引用类型。</li>
<li>不要捕获不能处理的异常。</li>
<li>不要使用 <code>throw()</code>，应该使用 <code>noexcept</code>。</li>
<li>尽可能使用标准库提供的异常类型，确实需要自定义异常类型，也应该继承标准的异常类型。</li>
<li>不要在析构函数或者内存释放函数中抛出异常。</li>
</ul>
<h2 id="异常处理和性能开销"><a href="#异常处理和性能开销" class="headerlink" title="异常处理和性能开销"></a>异常处理和性能开销</h2><p>如果没有异常抛出，异常机制会带来轻微的性能开销。如果有异常抛出，性能开销基本和函数调用差不多。</p>
<p><strong>大多数情况下，异常处理带来的性能和内存的损耗可以忽略不计。</strong></p>
<p>即使需要考虑性能的情况下，也应该知道，异常能够为程序提供更高的正确率，更好的维护性。</p>
<h2 id="异常-vs-断言"><a href="#异常-vs-断言" class="headerlink" title="异常 vs 断言"></a>异常 vs 断言</h2><p><strong>异常和断言是两种完全不同的用于检测程序运行时错误的机制。</strong></p>
<p>在开发过程中，使用断言来表示：只要你的代码是正确的，某些错误发生的条件一定不会成立。用异常来处理这种错误是没有意义的，因为它表明了代码中必然存在着需要修改的部分。断言不表示在某种错误条件成立的情况下，程序可以在运行时从错误中恢复。断言在声明处中止程序执行，从而可以让你用调试器检查程序的状态。</p>
<p>异常从首个满足异常类型的 <code>catch</code> 块继续执行。即使你的代码是正确的，运行时也可能会抛出异常，如 “file not found” 或 “out of memory”。<br>异常能够处理这些错误，哪怕只是记录日志信息，然后终止程序。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/errors-and-exception-handling-modern-cpp?view=msvc-160">https://docs.microsoft.com/en-us/cpp/cpp/errors-and-exception-handling-modern-cpp?view=msvc-160</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于编译告警 C4819 的完整解决方案</title>
    <url>/2021/03/17/cplusplus/compile-error-c4819/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>今天迁移开发环境的时候遇到一个问题，同样的操作系统和 Visual Studio 版本，原始开发环境一切正常，但是迁移后 VS 出现了 C4819 告警，上网查了中文的一些博客，大部分涵盖几种解决方案：</p>
<ul>
<li>修改工程文件或者源文件，禁用该告警</li>
<li>修改文件内容，避免使用非法字符</li>
<li>将文件重新以 Unicode 格式保存</li>
</ul>
<p>这些方案都不适用于我的问题，我并<strong>不想修改这些产生告警的头文件</strong>，因为这并不是我负责的模块，同时也并一定就是源文件的问题。</p>
<span id="more"></span>

<h2 id="问题调研"><a href="#问题调研" class="headerlink" title="问题调研"></a>问题调研</h2><p>不得已还是搜索了微软的官方文档，找到关于 C4819 告警的定义如下：</p>
<h3 id="Compiler-Warning-level-1-C4819"><a href="#Compiler-Warning-level-1-C4819" class="headerlink" title="Compiler Warning (level 1) C4819"></a>Compiler Warning (level 1) C4819</h3><blockquote>
<p>The file contains a character that cannot be represented in the current code page (number). Save the file in Unicode format to prevent data loss.</p>
</blockquote>
<h3 id="出现-C4819-的原因"><a href="#出现-C4819-的原因" class="headerlink" title="出现 C4819 的原因"></a>出现 C4819 的原因</h3><p>当编译 ANSI 源文件时，系统使用了无法显示所有字符的 codepage。</p>
<h3 id="消除该告警的完整解决方案："><a href="#消除该告警的完整解决方案：" class="headerlink" title="消除该告警的完整解决方案："></a>消除该告警的完整解决方案：</h3><ul>
<li>如果你不需要的话，可以移除非法字符，比如注释</li>
<li>使用 Unicode escape sequences 来创建只包含基本 ANSI 字符的文件</li>
<li>将文件重新以 Unicode 格式保存</li>
<li><strong>在控制面板中设置 codepage 以支持源文件中非法的字符集</strong></li>
</ul>
<p>关于什么是 Unicode escape sequences 可以参考 <a href="https://dencode.com/en/string/unicode-escape">https://dencode.com/en/string/unicode-escape</a></p>
<p>关于如何用 Unicode 格式保存文件可以参考原文，链接在文末。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>对于我不想修改源文件的情况，只能通过修改系统的 codepage 来解决，以英文操作系统为例，中文系统可以对照修改：</p>
<ul>
<li>打开 Control Panel</li>
<li>选择 Region (and Language)</li>
<li>选择 Administrative 页签</li>
<li>在 Language for non-Unicode programs 区域点击 “Change System Locale” 按钮</li>
<li>设置 Current system locale，比如 English (United States)。</li>
<li>点击 “OK” 保存。</li>
</ul>
<p>重新编译代码，确认问题已经解决。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-1-c4819?view=msvc-160">https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-1-c4819?view=msvc-160</a></li>
<li><a href="https://knowledgebase.progress.com/articles/Article/4677">https://knowledgebase.progress.com/articles/Article/4677</a></li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>你想知道的 std::vector::push_back 和 std::vector::emplace_back</title>
    <url>/2021/03/12/cplusplus/push-back-vs-emplace-back/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>C++ 11 后，标准库容器 <code>std::vector</code> 包含了成员函数 <code>emplace</code> 和 <code>emplace_back</code>。<code>emplace</code> 在容器指定位置插入元素，<code>emplace_back</code> 在容器末尾添加元素。</p>
<p><code>emplace</code> 和 <code>emplace_back</code> 原理类似，本文仅讨论 <code>push_back</code> 和 <code>emplace_back</code>。</p>
<span id="more"></span>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>首先看下 Microsoft Docs 对 <code>push_back</code> 和 <code>emplace_back</code> 的定义：</p>
<ul>
<li><code>push_back</code>：Adds an element to the end of the vector.</li>
<li><code>emplace_back</code>：Adds an element <strong>constructed in place</strong> to the end of the vector.</li>
</ul>
<p>两者的定义我用了加粗字体作区分，那么现在问题就在于什么叫做 <strong>constructed in place</strong> ？</p>
<p>再来看下官方文档（<a href="http://www.cplusplus.com)怎么介绍/">www.cplusplus.com）怎么介绍</a> <code>emplace_back</code> 的：</p>
<blockquote>
<p>template &lt;class… Args&gt;<br>  void emplace_back (Args&amp;&amp;… args);</p>
<blockquote>
<p>Inserts a new element at the end of the vector, right after its current last element. This new element is <strong>constructed in place using <code>args</code> as the arguments for its constructor</strong>.<br>This <strong>effectively</strong> increases the container size by one, which causes an automatic reallocation of the allocated storage space if -and only if- the new vector size surpasses the current vector capacity.<br>The element is constructed in-place by calling <code>allocator_traits::construct</code> with <code>args</code> forwarded.<br>A similar member function exists, <code>push_back</code>, which either <strong>copies or moves</strong> an existing object into the container.</p>
</blockquote>
</blockquote>
<p><strong>简而言之，<code>push_back</code> 会构造一个临时对象，这个临时对象会被拷贝或者移入到容器中，然而 <code>emplace_back</code> 会直接根据传入的参数在容器的适当位置进行构造而避免拷贝或者移动。</strong></p>
<h2 id="为什么我们有了-emplace-back-还需要-push-back？"><a href="#为什么我们有了-emplace-back-还需要-push-back？" class="headerlink" title="为什么我们有了 emplace_back 还需要 push_back？"></a>为什么我们有了 <code>emplace_back</code> 还需要 <code>push_back</code>？</h2><p>这部分内容进一步对如何区分 <code>push_back</code> 和 <code>emplace_back</code> 做了解答。<br>Stack Overflow 有一项回答我认为已经解释的较为清楚，因此这里部分转译过来。</p>
<p>翻译带有个人理解，非直译，原文参考：<a href="https://stackoverflow.com/questions/10890653/why-would-i-ever-use-push-back-instead-of-emplace-back">https://stackoverflow.com/questions/10890653/why-would-i-ever-use-push-back-instead-of-emplace-back</a></p>
<p><strong>以下为译文：</strong></p>
<p>关于这个问题我在过去 4 年思考良多，我敢说大多数关于 <code>push_back</code> 和 <code>emplace_back</code> 的解释都不够完善。</p>
<p>去年，我在一次关于 C++ 的介绍中（链接参考原文）讨论了 <code>push_back</code> 和 <code>emplace_back</code> 的相关议题，这两者最主要的区别来自于：<strong>是使用隐式构造函数还是显示构造函数</strong>（implicit vs. explicit constructors）。</p>
<p>先看下面的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;T&gt; v;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(x);</span><br><span class="line">v.<span class="built_in">emplace_back</span>(x);</span><br></pre></td></tr></table></figure>

<p>传统观点认为 <code>push_back</code> 会构造一个临时对象，这个临时对象会被移入到 <code>v</code> 中，然而 <code>emplace_back</code> 会直接根据传入的参数在适当位置进行构造而避免拷贝或者移动。从标准库代码的实现角度来说这是对的，但是对于提供了优化的编译器来讲，上面示例中最后两行表达式生成的代码其实没有区别。</p>
<p>真正的区别在于，<code>emplace_back</code> 更加强大，它可以调用任何类型的（只要存在）构造函数。而 <code>push_back</code> 会更加严谨，它只调用隐式构造函数。隐式构造函数被认为是安全的。如果能够通过对象 <code>T</code> 隐式构造对象 <code>U</code>，就认为 <code>U</code> 能够完整包含 <code>T</code> 的所有内容，这样将 <code>T</code> 传递给 <code>U</code> 通常是安全的。正确使用隐式构造的例子是用 <code>std::uint32_t</code> 对象构造 <code>std::uint64_t</code> 对象，错误使用隐式构造的例子是用 <code>double</code> 构造 <code>std::uint8_t</code>。</p>
<p>我们必须在编码时小心翼翼。我们不想使用强大/高级的功能，因为<strong>它越是强大，就越有可能发生意想不到的错误</strong>。如果想要调用显示构造函数，那么就调用 <code>emplace_back</code>。如果只希望调用隐式构造函数，那么请使用更加安全的 <code>push_back</code>。</p>
<p>再看个示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::unique_ptr&lt;T&gt;&gt; v;</span><br><span class="line">T a;</span><br><span class="line">v.<span class="built_in">emplace_back</span>(std::<span class="built_in">addressof</span>(a)); <span class="comment">// compiles</span></span><br><span class="line">v.<span class="built_in">push_back</span>(std::<span class="built_in">addressof</span>(a)); <span class="comment">// fails to compile</span></span><br></pre></td></tr></table></figure>

<p><code>std::unique_ptr&lt;T&gt;</code> 包含了显示构造函数通过 <code>T*</code> 进行构造。因为 <code>emplace_back</code> 能够调用显示构造函数，所以传递一个裸指针并不会产生编译错误。然而，当 <code>v</code> 超出了作用域，<code>std::unique_ptr&lt;T&gt;</code> 的析构函数会尝试 <code>delete</code> 类型 <code>T*</code> 的指针，而类型 <code>T*</code> 的指针并不是通过 <code>new</code> 来分配的，因为它保存的是栈对象的地址，因此 <code>delete</code> 行为是未定义的。</p>
<p>这不是为了示例而特意写的代码，而是一个我遇到的实际问题。原本 <code>v</code> 是 <code>std::vector&lt;T *&gt;</code> 类型，迁移到 C++ 11 后，我修改为 <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code>。并且，那时我错误地认为 <code>emplace_back</code> 能够做 <code>push_back</code> 所能做的所有事情，因此将 <code>push_back</code> 也改为了 <code>emplace_back</code>。</p>
<p>如果我保留使用更加安全的 <code>push_back</code>，那么我会立马发现这个 bug。不幸的是，我意外地隐藏了这个 bug 并直到几个月后才重新发现它。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/vector-class?view=msvc-160">https://docs.microsoft.com/en-us/cpp/standard-library/vector-class?view=msvc-160</a></li>
<li><a href="https://www.cplusplus.com/reference/vector/vector/emplace_back/">https://www.cplusplus.com/reference/vector/vector/emplace_back/</a></li>
<li><a href="https://stackoverflow.com/questions/10890653/why-would-i-ever-use-push-back-instead-of-emplace-back">https://stackoverflow.com/questions/10890653/why-would-i-ever-use-push-back-instead-of-emplace-back</a></li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Dump 文件？</title>
    <url>/2021/03/11/cplusplus/how-to-use-dump-file/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文概述了使用 WinDbg 的一些必要步骤。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>第一步，你必须更改系统的配置使其能够生成 PDB 文件，包括 Release 版本。近期的 Visual C++ 编译器默认启用此配置，但早期某些版本编译器需要你手动开启此选项。保留每个版本的 PDB 文件，这很重要！</p>
<p>第二步，你必须确定生成 dump 文件的应用程序版本。当你自己生成了 MiniDumps（比如通过调用 MiniDumpWriteDump()）的时候，最好在 MiniDump 的文件名里加上应用程序的完整版本号。当然，这需要有一个完善的版本控制机制，比如任何分支的任何编译都会更新版本号。</p>
<p>现在假设你已经获取了 dump 文件，你准确地知道生成 dump 文件的应用程序版本，以及该版本的 PDB 文件。</p>
<p>第三步，在你的代码库历史记录中找到该版本的源代码，放在一个单独目录。</p>
<span id="more"></span>

<h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>现在你可以选择使用 WinDbg 或者 Visual C++ 来调试 dump 文件了。使用 Visual Studio 更加简单，但是 WinDbg 更加强大。大多数情况下 Visual Studio 的功能已经能够满足需求了。</p>
<p>如果使用 Visual Studio，你需要在 Visual Studio 中添加文件的方式打开 dump 文件:</p>
<p><img src="dump_page_vs.png" alt="Dump file page in VS"></p>
<p>然后 debug dump 文件。如果所有的路径（源代码和 PDB 文件）都配置正确，那么你就能够调试到 crash 的地方，查看 call stack 等内容。</p>
<p>如果使用 WinDbg，你需要：</p>
<ol>
<li>打开 WinDbg 工具</li>
<li>打开 dump 文件（默认是 Ctrl + D）</li>
<li>告诉 WinDbg 加载正确的 MicroSoft symbol 文件，命令：<code>.symfix</code>，这个过程可能需要一些时间</li>
<li>告诉 WinDbg 加载 程序的 PDB 文件，命令：<code>.sympath+ c:\pdblocation</code>，将 “c:\pdblocation” 替换为你自己的 PDB 路径。注意 <code>.sympath</code> 和 <code>+</code> 之间不要有空格,否则可能会破坏步骤 3. 中的工作。</li>
<li>告诉 WinDbg 源代码的位置，命令：<code>.srcpath c:\app_build_1.0.100</code>，将 “c:\app_build_1.0.100” 替换为你自己的源代码路径。</li>
<li>告诉 WinDbg 可以开始分析 dump 文件了，命令：<code>!analyze -v</code>。</li>
</ol>
<p>如果所有配置都是正确的，那么后面 WinDbg 就会运行到 crash 的位置，之后你就可以对应用程序进行深入分析，这部分内容不在本文讨论范围之内。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://stackoverflow.com/questions/734272/how-to-use-windbg-to-analyze-the-crash-dump-for-vc-application">https://stackoverflow.com/questions/734272/how-to-use-windbg-to-analyze-the-crash-dump-for-vc-application</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 PDB 文件你需要知道什么？</title>
    <url>/2021/03/10/cplusplus/what-you-should-known-4-pdb-file/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大多数人知道 PDB 文件是用来帮助我们 debug 的，但也仅此而已。</p>
<p>本文主要介绍当你遇到 PDB 文件时（windows 开发中），你必须要知道的内容。</p>
<h2 id="重要的事情说三遍"><a href="#重要的事情说三遍" class="headerlink" title="重要的事情说三遍"></a>重要的事情说三遍</h2><p><strong>PDB 文件和源代码一样重要！！!</strong> </p>
<p><strong>PDB 文件和源代码一样重要！！!</strong> </p>
<p><strong>PDB 文件和源代码一样重要！！!</strong> </p>
<span id="more"></span>


<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>首先定义两个概念：</p>
<ul>
<li><strong>本地编译</strong>：在你本机开发环境中的编译。</li>
<li><strong>官方编译</strong>：在编译服务器上的编译。</li>
</ul>
<p>这两种编译的区分很重要，因为调试本地编译往往很简单，但是问题往往出现在官方编译中。</p>
<p>官方编译至少需要有一个地方（Symbol Server）来存放编译出来的二进制及 PDB 文件。这样当某个版本发现任何问题，我们可以获取到对应的 PDB 文件进行调试。<br>没有匹配的 PDB 文件，调试器几乎不可能完成调试任务，或者你将付出高昂的代价才能解决问题。</p>
<blockquote>
<p>更多关于 Symbol Server 的内容，参考 <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2002/june/bugslayer-symbols-and-crash-dumps">https://docs.microsoft.com/en-us/archive/msdn-magazine/2002/june/bugslayer-symbols-and-crash-dumps</a></p>
</blockquote>
<p>Visual Studio 和 WinDBG 知道如何访问 Symbol Server 并且如果二进制文件来自官方编译，那么调试器能够自动加载匹配的 PDF 文件。</p>
<p>在将 PDB 文件放在 Symbol Server 上之前，还需要做一件事：在官方编译出来的 PDB 文件上，通过 Source Server 工具，进行源文件索引（source indexing）。索引过程会嵌入版本控制命令用于拉取当前版本编译的源文件。这样，当你调试当前版本时，你就不用担心找不到版本的源文件。</p>
<blockquote>
<p>更多关于 Source Server 的内容，参考 <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2006/august/source-server-helps-you-kill-bugs-dead-in-visual-studio-2005">https://docs.microsoft.com/en-us/archive/msdn-magazine/2006/august/source-server-helps-you-kill-bugs-dead-in-visual-studio-2005</a></p>
</blockquote>
<h2 id="什么是-PDB-文件？"><a href="#什么是-PDB-文件？" class="headerlink" title="什么是 PDB 文件？"></a>什么是 PDB 文件？</h2><p>现在，我们可以开始介绍什么是 PDB 文件，以及调试器是如何查找 PDB 文件了。<br>实际的 PDB 文件格式是加密的，但是微软提供了 API，为调试器提供 PDB 文件的数据。</p>
<p>非托管的 C++ PDB 文件包含了以下信息：</p>
<ul>
<li>公有函数，私有函数和静态函数的地址</li>
<li>全局变量的名称和地址</li>
<li>参数和局部变量的名称以及栈上的偏移量</li>
<li>类，结构体以及数据定义的类型信息</li>
<li>FPO（Frame Pointer Omission） 数据</li>
<li>源文件的文件名及行信息。</li>
</ul>
<p>而 .NET 的 PDB 文件只包含了两项内容：</p>
<ul>
<li>源文件的文件名及行信息</li>
<li>局部变量的名称</li>
</ul>
<p>其他所有信息已经存放在 .NET 元数据中，所以没有必要再 PDB 文件中冗余。</p>
<h2 id="PDB-文件的加载"><a href="#PDB-文件的加载" class="headerlink" title="PDB 文件的加载"></a>PDB 文件的加载</h2><p>当模块被加载到进程的地址空间后，调试器会使用两种信息找到匹配的 PDB 文件。首先，当然是文件名。如果你加载 ZZZ.DLL，那么调试器就会查找 ZZZ.PDB。<br>更重要的是，调试器如何知道这就是匹配的 PDB 文件？这是通过比对内嵌于 PDB 文件和二进制文件中的 GUID 来确认的。</p>
<p>负责将 GUID 嵌入二进制和 PDB 文件的是编译器（.NET）或者链接器（C++）。想想，历史编译的版本如果没有保存 PDB 文件，你还能调试吗？答案是否定的，哪怕你没有修改源文件！你可能会想是否可以修改 PDB 文件的 GUID？很遗憾，答案也是否定的。</p>
<p>你可以查看二进制文件中的 GUID。使用 Visual Studio -&gt; DUMPBIN 的命令行工具，你可以列出所有的 PE（Portable Executable） 文件内容。可以在 Visual Studio 的命令行工具中调用 DUMPBIN。</p>
<blockquote>
<p>更多关于 DUMPBIN 的内容参考：<a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2002/february/inside-windows-win32-portable-executable-file-format-in-detail">https://docs.microsoft.com/en-us/archive/msdn-magazine/2002/february/inside-windows-win32-portable-executable-file-format-in-detail</a> 和 <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2002/march/inside-windows-an-in-depth-look-into-the-win32-portable-executable-file-format-part-2">https://docs.microsoft.com/en-us/archive/msdn-magazine/2002/march/inside-windows-an-in-depth-look-into-the-win32-portable-executable-file-format-part-2</a></p>
</blockquote>
<p>DUMPBIN 有很多命令行指令，其中显示 GUID 的指令是 /HEADERS。在输出内容中，对我们来说重要的是 Debug Directories 部分的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Debug Directories</span><br><span class="line"></span><br><span class="line">        Time Type        Size      RVA  Pointer</span><br><span class="line">    -------- ------- -------- -------- --------</span><br><span class="line">    6045C20E cv            60 00541AC8   5408C8    Format: RSDS, &#123;DC80D058-127B-4379-B859-3F9F6978A4DB&#125;, 1, C:ZZZ.pdb</span><br></pre></td></tr></table></figure>

<p>知道了调试器如何确定匹配的 PDB 文件，下一步我们讨论调试器从哪里查找 PDB 文件。首先，调试器会在加载二进制文件的目录查找对应的 PDB 文件，如果没有找到，那么就查找PE 文件中 Debug Directories 内容里硬编码的 PDB 文件路径，在上面的输出示例中是 “C:ZZZ.pdb”（.NET 应用编译工具 MSBUILD会将 PDB 文件编译到 OBJ&lt;Debug/Relase/…&gt; 目录下，如果编译成功，再拷贝到 DEBUG 或者 RELEASE 目录）。如果在上述两个位置都没有找到，但是建立了 Symbol Server，那么调试器会在 Symbol Server 的缓存目录里继续查找。这种查找顺序也保证了本地编译和官方编译不会有冲突。</p>
<p>在 Visual Studio 中调试的时候，你可以在窗口 Modules 中的列 Symbol File 里看到 PDB 文件的位置。 </p>
<p>对大多数应用来讲这种加载方式都没有问题。但是对于需要将程序集放入 GAC（Global Assembly Cache）的 .NET 应用，PDB 的加载就会变得有趣了。对于本地编译，调试器会在编译目录找到 PDB 文件，所以没什么问题。问题来源于当你想要在其他机器上调试本地编译版本。</p>
<p>在其他机器上调式，很多人会用 Gacutil.exe 将程序集放入 GAC，然后打开命令行在 “C:WINDOWSASSEMBLY” 下查找程序集的物理位置。但是基于 Any CPU 编译的程序集实际上会放入类似 “C:WindowsassemblyGAC_MSILExample1.0.0.0__682bc775ff82796a” 的路径。</p>
<p>上述路径中，Example 是程序集名称，1.0.0.0 是版本号，682bc775ff82796a 是公有秘钥令牌值（public key token value）。当你推断出这个路径后，你可以将 PDB 文件拷入这个目录然后调试器会加载它。</p>
<h2 id="PDB-文件的内容"><a href="#PDB-文件的内容" class="headerlink" title="PDB 文件的内容"></a>PDB 文件的内容</h2><p>对于官方编译，因为有源文件索引工具，所以 PDB 文件中会存储版本控制命令，用于将源文件放入你配置的源文件缓存池。对于本地编译，PDB 文件中存储的是二进制文件对应的源文件的完整路径。换句话说，如果你使用 C:FOO 中的源文件 MYCODE.CPP，那么 PDB 文件中存储的就是 C:FOOMYCODE.CPP。</p>
<p>理论上，所有的官方编译会自动立马进行源文件索引，并将内容存储于 Symbol Server，以至于你都不用考虑源文件在哪。然而，有些开发团队在测试及其他环节中会考量编译结果是否满足使用的要求，在此之前，不会对 PDB 文件进行源文件索引。如果你确实需要调试未索引的版本，最好将源代码下载到本地时保证和编译服务器相同的磁盘和目录，否则，你可能会在调试时遇到麻烦。尽管 Visual Studio 调试器和 WinDBG 有配置源文件搜索路径的选项，但要配置正确并不容易。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.wintellect.com/pdb-files-what-every-developer-must-know/">https://www.wintellect.com/pdb-files-what-every-developer-must-know/</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>图解哈希表及其原理</title>
    <url>/2021/03/09/cplusplus/hash-map/</url>
    <content><![CDATA[<h2 id="要点回顾"><a href="#要点回顾" class="headerlink" title="要点回顾"></a>要点回顾</h2><blockquote>
<p>此部分方便知识点快速回顾，首次阅读请从引言部分开始。</p>
</blockquote>
<ul>
<li>哈希表（Hash Table）其实也叫散列表，是一个数据结构。</li>
<li>哈希表本质上就是一个数组，只不过数组存放的是单一的数据，而哈希表中存放的是键值对（key - value pair）。</li>
<li>key 通过哈希函数（hash function）得到数组的索引，进而存取索引位置的值。</li>
<li>不同的 key 通过哈希函数可能得到相同的索引值，此时，产生了哈希碰撞。</li>
<li>通过在数组中插入链表或者二叉树，可以解决哈希碰撞问题。</li>
</ul>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>哈希这个词想必大家经常听到，这也说明了它使用的频繁程度，HashMap 和 HashTable 都与哈希这个词有关系。那哈希是什么，要搞清楚它，我们得先来说下哈希表。</p>
<h2 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h2><p><strong>哈希表（Hash Table）</strong> 是一种用于存储 <strong>键值对</strong> 的基本数据结构。在 C++ 中，哈希表使用 <strong>哈希函数</strong> 来计算数组的索引，进而存取数组中对应索引位置的值。</p>
<p>百科定义：</p>
<blockquote>
<p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
</blockquote>
<p>计算索引的过程被称为 <strong>哈希（hash）</strong>。</p>
<h2 id="哈希表实现原理"><a href="#哈希表实现原理" class="headerlink" title="哈希表实现原理"></a>哈希表实现原理</h2><p>用一个简单的例子来说明哈希表的原理：</p>
<p><strong>假设</strong>：有一本中文词典，里面包含了所有的汉字，但是这些汉字是按任意顺序随意排版的，那么想要在其中找到某一个汉字，你就需要从头至尾一个一个核查，如果运气差，这个汉字正好在词典的末尾，那你需要遍历整本词典才能找到你要查的汉字。</p>
<p><strong>优化</strong>：因为汉字和拼音之间存在着一种确定的关系，为了提高查找速度，现在将所有汉字按照拼音（key）进行排序（拼音可以根据首字母，第二个字母依次进一步排序），并且每个拼音都有一个对应页码（index），从该页开始，存放拼音对应的汉字（value）。所以找到拼音，也就能在对应的页码找到对应的汉字。其中，拼音和页码之间，有着某种固定的映射关系，可以通过某种方式计算出来（hash function）。</p>
<p>由此可见，哈希表可以根据一个 key 值来直接访问数据，因此查找速度快。</p>
<p><strong>但是</strong>，上面的例子，还存在一个问题，放在同一页码（具有相同拼音）的汉字可能不止一个（同音字），这时候通过拼音（key）获取到的汉字（value）应该是哪个呢？这就出现了<strong>碰撞（hash collision）</strong>。</p>
<p>为了解决碰撞，实现哈希表可以有以下两种方式：</p>
<ul>
<li>数组 + 链表</li>
<li>数组 + 二叉树</li>
</ul>
<p>所以，<strong>哈希表本质上就是一个数组</strong>。只不过数组存放的是单一的数据，而哈希表中存放的是键值对。</p>
<p>链表或二叉树是用来解决碰撞的。</p>
<p>下面用图例说明哈希表以及解决哈希碰撞的链表实现：</p>
<p><img src="hash_map.bmp"></p>
<p>因为哈希表中 key 必须是唯一的，所以图示给拼音加了后缀 _1 和 _2。key <em>han_1</em> 和 <em>han_2</em> 通过哈希函数 <em>F(x)</em> 计算出来的页码都是 <em>244</em>。这时就产生了哈希碰撞。为了解决碰撞问题，新建了一个链表，链表的每个结点都包含了一个键值对，当输入 key <em>han_2</em> 时，哈希表在 <em>244</em> 位置找到了键值对 *[han_1 - 汉]*，但是通过比对发现找到的键值对的 key 是 <em>han_1</em>，不等于 <em>han_2</em>，所以继续遍历到链表的下一个结点，下一个结点存放了键值对 <em>[han_2 - 汗]<em>，通过比较发现 key 确实是 <em>han_2</em>，因此返回了汉字（value）</em>汗</em>。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.educba.com/c-plus-plus-hash-table/">https://www.educba.com/c-plus-plus-hash-table/</a></p>
<p><a href="https://mp.weixin.qq.com/s/AkPIN6Ugno9vkQ2AAmCEAA">https://mp.weixin.qq.com/s/AkPIN6Ugno9vkQ2AAmCEAA</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的虚函数表及虚函数执行原理</title>
    <url>/2021/03/05/cplusplus/virtual-function/</url>
    <content><![CDATA[<h2 id="要点回顾"><a href="#要点回顾" class="headerlink" title="要点回顾"></a>要点回顾</h2><blockquote>
<p>此部分方便知识点快速回顾，首次阅读请从引言部分开始。</p>
</blockquote>
<ul>
<li><p>每个包含虚函数的类（或者继承自的类包含了虚函数）都有一个自己的虚函数表，这个表是一个在<strong>编译时确定</strong>的静态数组。</p>
</li>
<li><p>虚函数表包含了指向每个虚函数的函数指针以供类对象调用。</p>
</li>
<li><p>编译器在基类中定义了一个隐藏指针<code>*__vptr</code>，<code>*__vptr</code> 是在类实例创建时自动赋值的，以指向类的虚函数表。</p>
</li>
<li><p>通过虚函数表，编译器和程序能够确定调用什么版本的虚函数，尽管使用的是指向/引用基类的指针或者引用。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>为了实现虚函数，C++ 使用了虚函数表来达到延迟绑定的目的。虚函数表在动态/延迟绑定行为中用于查询调用的函数。</p>
<h2 id="什么是虚函数表？"><a href="#什么是虚函数表？" class="headerlink" title="什么是虚函数表？"></a>什么是虚函数表？</h2><p>尽管要描述清楚虚函数表的机制会多费点口舌，但其实其本身还是比较简单的。</p>
<p>首先，每个包含虚函数的类（或者继承自的类包含了虚函数）都有一个自己的虚函数表。这个表是一个在编译时确定的静态数组。虚函数表包含了指向每个虚函数的函数指针以供类对象调用。</p>
<p>其次，编译器还在基类中定义了一个隐藏指针，我们称为 <code>*__vptr</code>，<code>*__vptr</code> 是在类实例创建时自动赋值的，以指向类的虚函数表。<code>*__vptr</code> 是一个真正的指针，这和 <code>*this</code> 指针不同，<code>*this</code> 指针实际是一个函数参数，使编译器来达到自引用的目的。</p>
<p>结果就是，每个类对象都会多分配一个指针的大小，并且 <code>*__vptr</code> 是被派生类继承的。</p>
<p>如果你不清楚这些组件是怎么配合运作的，看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为这里有 3 个类，编译器会创建 3 个虚函数表。</p>
<p>然后编译器会在使用了虚函数的最上层基类中定义一个隐藏指针。尽管这个过程编译器会自动处理，但我们还是通过下面的例子来说明指针添加的位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FunctionPointer *__vptr;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>*__vptr</code> 在类对象创建的时候会设置成指向类的虚函数表。例如，类型 <code>Base</code> 被实例化的时候，<code>*__vptr</code> 就指向 <code>Base</code> 的虚函数表。类型 <code>D1</code> 或者 <code>D2</code> 被实例化的时候，<code>*__vptr</code> 就指向 <code>D1</code> 或者 <code>D2</code> 的虚函数表。</p>
<p>现在我们来看下虚函数表是怎么创建的。因为示例中每个类仅有 2 个虚函数，所以每个虚函数表会存放两个函数指针（分别指向 <code>function1()</code> 和 <code>function2()</code>）。</p>
<p><code>Base</code> <code>对象的虚函数表最简单。Base</code> 对象只能访问 <code>Base</code> 类型的成员，不能访问 <code>D1</code> 或者 <code>D2</code> 的函数。所以 <code>Base</code> 的虚函数表中的两个指针分别指向 <code>Base::function1()</code> 和 <code>Base::function2()</code>。</p>
<p><code>D1</code> 的虚函数表稍复杂点，<code>D1</code> 对象能够访问 <code>D1</code> 以及 <code>Base</code> 的成员。<code>D1</code> 重写了 <code>function1()</code>，但没有重写 <code>function2()</code>，所以 <code>D1</code> 的虚函数表中的两个指针分别指向 <code>D1::function1()</code> 和 <code>Base::function2()</code>。</p>
<p><code>D2</code> 的虚函数表同理 <code>D1</code>，包含了分别指向 <code>Base::function1()</code> 和 <code>D2::function2()</code> 的指针。</p>
<p><img src="VTable.gif" alt="Virtual Table"><br/></p>
<p>考虑如果创建 <code>D1</code> 对象时会发生什么：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>d1</code> 是 <code>D1</code> 类型对象，<code>d1</code> 有它自己的 <code>*__vptr</code> 指向 <code>D1</code> 类型的虚函数表。</p>
<p>现在创建一个 <code>Base</code> 类型指针 <code>*dPtr</code> 指向 <code>d1</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d1;</span><br><span class="line">    Base *dPtr = &amp;d1;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点：</p>
<blockquote>
<p>因为 <code>dPtr</code> 是 <code>Base</code> 类型指针，它只指向 <code>d1</code> 对象的 <code>Base</code> 类型部分(即，指向 <code>d1</code> 对象中的 <code>Base</code> 子对象)，而  <code>*__vptr</code> 也在 <code>Base</code> 类型部分。所以 <code>dPtr</code> 可以访问 <code>Base</code> 类型部分中的 <code>*__vptr</code>。同时，这里注意，<code>dPtr-&gt;__vptr</code> 指向的是 <code>D1</code> 的虚拟函数表，这是在 <code>d1</code> 初始化时就确定的。所以结果，尽管 <code>dPtr</code> 是 <code>Base</code> 类型指针，但它能够访问 <code>D1</code> 的虚函数表。</p>
</blockquote>
<p>因此，当有调用 <code>dPtr-&gt;function1()</code> 时，发生了什么？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d1;</span><br><span class="line">    Base *dPtr = &amp;d1;</span><br><span class="line">    dPtr-&gt;<span class="built_in">function1</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，程序识别到 <code>function1()</code> 是一个虚函数。<br/><br>其次，程序使用 <code>dPtr-&gt;__vptr</code> 获取到了 <code>D1</code> 的虚函数表。<br/><br>然后，它在 <code>D1</code> 的虚函数表中寻找可以调用的 <code>function1()</code> 版本，这里是 <code>D1::function1()</code>。<br/><br>因此，<code>dPtr-&gt;function1()</code> 实际调用了 <code>D1::function1()</code>。</p>
<p>通过虚函数表，编译器和程序能够确定调用什么版本的虚函数，尽管使用的是指向/引用基类的指针或者引用。</p>
<p>调用虚函数会比调用非虚函数更慢，有以下几个原因：</p>
<ul>
<li>必须使用 <code>*__vptr</code> 获取正确的虚函数。</li>
<li>必须建立虚函数表的索引来获取想要调用的函数。</li>
<li>调用找到的函数。</li>
</ul>
<p>结果就是必须进行三次操作才能完成对函数的调用。但是对于现代计算机系统，这些额外操作增加的时间几乎可以忽略不计。</p>
<p>另外，每个使用虚函数表的类都有 <code>*__vptr</code> 指针，从而每个类对象都会多一个指针的空间。虚函数很强大，但是它确实产生了性能开销。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 C++ 中的强制转换 - 基础篇</title>
    <url>/2021/03/04/cplusplus/cast-in-cplusplus/</url>
    <content><![CDATA[<h2 id="要点回顾"><a href="#要点回顾" class="headerlink" title="要点回顾"></a>要点回顾</h2><blockquote>
<p>此部分方便知识点快速回顾，首次阅读请从引言部分开始。</p>
</blockquote>
<ul>
<li>常用的强制转换为 <code>dynamic_cast</code> 和 <code>static_cast</code>。</li>
<li>除非必须，不要使用 <code>const_cast</code> 和 <code>reinterpret_cast</code>，因为它们存在一些老式 C 语言转换中的隐患。</li>
<li><code>dynamic_cast</code> 主要用于多态类型的强制转换，而 <code>static_cast</code> 主要用于非多态类型的强制转换。</li>
<li><code>static_cast</code> 转换不像 <code>dynamic_cast</code> 那样安全。因为 <code>static_cast</code> 没有运行时检测。通过 <code>dynamic_cast</code> 进行转换时，一旦存在歧义，就会导致失败，然而 <code>static_cast</code> 会像没有错误发生一样返回结果。尽管 <code>dynamic_cast</code> 更加安全，但 <code>dynamic_cast</code> 仅适用于指针和引用，并且运行时检测是需要消耗性能的。</li>
</ul>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>假设有基类 <code>A</code>，包含了虚函数 <code>func1</code>，以及有派生类 <code>B</code>，继承于类 <code>A</code>，派生类 <code>B</code> 中实现了函数 <code>func1</code>。此时可以用 <code>A</code> 类型的指针指向 <code>B</code> 类型的对象，并用 <code>A</code> 类型的指针调用 <code>B</code> 类型对象中的函数 <code>func1</code>。这时，就形成了<strong>多态</strong>。包含虚函数的类 <code>A</code>，我们也称为<strong>多态类</strong>。</p>
<p>由于派生类 <code>B</code> 完整包含了 基类 <code>A</code> 的所有定义，将 <code>B</code> 类型的指针转换为 <code>A</code> 类型的指针<strong>总是安全的</strong>。</p>
<p>而将 <code>A</code> 类型的指针强制转换为 <code>B</code> 类型的指针时，如果 <code>A</code> 类型指针指向的对象确实为 <code>B</code> 类型的对象，那么转换<strong>也是安全的</strong>。此时，该 <code>B</code> 类型对象被称为<strong>完整对象</strong>(complete object)。</p>
<h2 id="强制转换有哪些类型？"><a href="#强制转换有哪些类型？" class="headerlink" title="强制转换有哪些类型？"></a>强制转换有哪些类型？</h2><p>C++ 包含了以下几种强制转换运算符，这些运算符用于消除老式 C 语言转换中的存在的歧义和隐患：</p>
<blockquote>
<ul>
<li><code>dynamic_cast</code></li>
<li><code>static_cast</code></li>
<li><code>const_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li><code>safe_cast</code></li>
</ul>
</blockquote>
<p>本文会着重介绍如何使用 <code>dynamic_cast</code> 和 <code>static_cast</code>。</p>
<p>提醒：</p>
<blockquote>
<p>除非必须，不要使用 <code>const_cast</code> 和 <code>reinterpret_cast</code>，因为它们存在一些老式 C 语言转换中的隐患。</p>
</blockquote>
<hr>
<h3 id="1、dynamic-cast-运算符"><a href="#1、dynamic-cast-运算符" class="headerlink" title="1、dynamic_cast 运算符"></a>1、<strong>dynamic_cast</strong> 运算符</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dynamic_cast &lt;type-id&gt; (expression)</span><br></pre></td></tr></table></figure>

<p><code>type-id</code> 必须是一个指针或者引用，指向/引用已定义的类类型或者 void。如果<code>type-id</code> 是指针，则 <code>expression</code> 必须也为指针类型，如果 <code>type-id</code> 是引用，<code>expression</code> 必须为左值类型。</p>
<p>如果 <code>type-id</code> 是 void*，那么在运行时将检测 <code>expression</code> 的实际类型。其结果返回 <code>expression</code> 指向的完整对象。</p>
<p>如非需要，现代 C++ 中应该避免使用 <code>void</code> 指针，因为容易出错。</p>
<p>下面看些示例，了解 <code>dynamic_cast</code> 的使用方式。</p>
<p>示例1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> :</span> <span class="keyword">public</span> Root &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Derived* pd)</span> </span>&#123;</span><br><span class="line">   Base* pb = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(pd);   <span class="comment">// ok: Base is a direct base class</span></span><br><span class="line">                                   <span class="comment">// pb points to Base subobject of pd</span></span><br><span class="line">   Root* pr = <span class="keyword">dynamic_cast</span>&lt;Root*&gt;(pd);   <span class="comment">// ok: Root is an indirect base class</span></span><br><span class="line">                                   <span class="comment">// pr points to Root subobject of pd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例1 中提到了<strong>子对象</strong>(subobject)的概念，注意与<strong>子类型</strong>进行区分：</p>
<blockquote>
<ul>
<li><code>Root</code> 类型包含子类型 <code>Base</code>，<code>Base</code> 类型包含子类型 <code>Derived</code>。  </li>
<li><code>Derived</code> 对象包含了 <code>Base</code> 类型的子对象，<code>Base</code> 类型的子对象又包含了 <code>Root</code> 类型的子对象。</li>
</ul>
</blockquote>
<p>再联系下前面说的：派生类完整包含了基类的所有定义。</p>
<p>示例2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   B* pb = <span class="keyword">new</span> D;   <span class="comment">// unclear but ok</span></span><br><span class="line">   B* pb2 = <span class="keyword">new</span> B;</span><br><span class="line"></span><br><span class="line">   D* pd = <span class="keyword">dynamic_cast</span>&lt;D*&gt;(pb);   <span class="comment">// ok: pb actually points to a D</span></span><br><span class="line">   D* pd2 = <span class="keyword">dynamic_cast</span>&lt;D*&gt;(pb2);   <span class="comment">// pb2 was nullptr.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例2 中 通过 <code>dynamic_cast</code> 转换为 <code>pd2</code> 时，不会报错，返回 <code>nullptr</code>。但如果同样地情况转换的对象是引用类型，那么运行时会抛出 <code>std::bad_cast</code> 异常。如果 <code>pb2</code> 指向/引用的对象无效，同样也会抛出异常。</p>
<p>示例3：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf_s</span>(<span class="string">&quot;in A\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf_s</span>(<span class="string">&quot;in B\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf_s</span>(<span class="string">&quot;test2 in B\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> B &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf_s</span>(<span class="string">&quot;in C\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf_s</span>(<span class="string">&quot;test2 in C\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Globaltest</span><span class="params">(A&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        C &amp;c = <span class="keyword">dynamic_cast</span>&lt;C&amp;&gt;(a);</span><br><span class="line">        <span class="built_in">printf_s</span>(<span class="string">&quot;in GlobalTest\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(std::bad_cast) &#123;</span><br><span class="line">        <span class="built_in">printf_s</span>(<span class="string">&quot;Can&#x27;t cast to C\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *pa = <span class="keyword">new</span> C;</span><br><span class="line">    A *pa2 = <span class="keyword">new</span> B;</span><br><span class="line"></span><br><span class="line">    pa-&gt;<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">    B * pb = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pa);</span><br><span class="line">    <span class="keyword">if</span> (pb)</span><br><span class="line">        pb-&gt;<span class="built_in">test2</span>();</span><br><span class="line"></span><br><span class="line">    C * pc = <span class="keyword">dynamic_cast</span>&lt;C *&gt;(pa2);</span><br><span class="line">    <span class="keyword">if</span> (pc)</span><br><span class="line">        pc-&gt;<span class="built_in">test2</span>();</span><br><span class="line"></span><br><span class="line">    C ConStack;</span><br><span class="line">    <span class="built_in">Globaltest</span>(ConStack);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// will fail because B knows nothing about C</span></span><br><span class="line">    B BonStack;</span><br><span class="line">    <span class="built_in">Globaltest</span>(BonStack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in C</span><br><span class="line">test2 in B</span><br><span class="line">in GlobalTest</span><br><span class="line">Can&#39;t cast to C</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2、static-cast-运算符"><a href="#2、static-cast-运算符" class="headerlink" title="2、static_cast 运算符"></a>2、<strong>static_cast</strong> 运算符</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static_cast &lt;type-id&gt; (expression)</span><br></pre></td></tr></table></figure>

<p><code>static_cast</code> 通常用于数值类型转换，例如枚举和整型，整型和浮点类型的转换。</p>
<p>在标准 C++ 中，<code>static_cast</code> 转换没有运行时检测来保证安全性。在 C++/CX 中，则包含了编译和运行时检测。</p>
<p><code>static_cast</code> 运算符能够用于将基类指针转换为派生类指针，但这样的转换不总是安全的。</p>
<p>下面还是通过示例进行讲解。</p>
<p>示例1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(B* pb, D* pd)</span> </span>&#123;</span><br><span class="line">   D* pd2 = <span class="keyword">static_cast</span>&lt;D*&gt;(pb);   <span class="comment">// Not safe, D can have fields</span></span><br><span class="line">                                   <span class="comment">// and methods that are not in B.</span></span><br><span class="line"></span><br><span class="line">   B* pb2 = <span class="keyword">static_cast</span>&lt;B*&gt;(pd);   <span class="comment">// Safe conversion, D always</span></span><br><span class="line">                                   <span class="comment">// contains all of B.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例1 中 <code>pd2</code> 不为空，当用指针 <code>pd2</code> 调用 <code>B</code> 类型对象不存在的方法或者成员时可能会发生运行时错误（比如调用虚函数）或者返回非预期的值。</p>
<p>示例2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> ch;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">65</span>;</span><br><span class="line">   <span class="keyword">float</span> f = <span class="number">2.5</span>;</span><br><span class="line">   <span class="keyword">double</span> dbl;</span><br><span class="line"></span><br><span class="line">   ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(i);   <span class="comment">// int to char</span></span><br><span class="line">   dbl = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(f);   <span class="comment">// float to double</span></span><br><span class="line">   i = <span class="keyword">static_cast</span>&lt;BYTE&gt;(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例2 中 <code>static_cast</code> 运算符显示地将内置类型进行转换。</p>
<p>关于 <code>static_cast</code> 运算符，还有以下几种使用情况：</p>
<blockquote>
<ul>
<li><code>static_cast</code> 能够显式的将整型转换为枚举类型。如果整型值不在枚举值范围内，那么返回的枚举值是未定义的。 </li>
<li><code>static_cast</code> 能将任何 <code>expression</code> 显式地转换为 <code>void</code> 类型。</li>
<li><code>static_cast</code> 操作符不会去除 <code>const</code>，<code>volatile</code>，<code>__unaligned</code> 属性。</li>
</ul>
</blockquote>
<h2 id="区分几种强制转换的使用场景"><a href="#区分几种强制转换的使用场景" class="headerlink" title="区分几种强制转换的使用场景"></a>区分几种强制转换的使用场景</h2><p><code>dynamic_cast</code> 主要用于多态类型的强制转换，而 <code>static_cast</code> 主要用于非多态类型的强制转换。</p>
<p><code>static_cast</code> 转换不像 <code>dynamic_cast</code> 那样安全。因为 <code>static_cast</code> 没有运行时检测。通过 <code>dynamic_cast</code> 进行转换时，一旦存在歧义，就会导致失败，然而 <code>static_cast</code> 会像没有错误发生一样返回结果。尽管 <code>dynamic_cast</code> 更加安全，但 <code>dynamic_cast</code> 仅适用于指针和引用，并且运行时检测是需要消耗性能的。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(B* pb)</span> </span>&#123;</span><br><span class="line">   D* pd1 = <span class="keyword">dynamic_cast</span>&lt;D*&gt;(pb);</span><br><span class="line">   D* pd2 = <span class="keyword">static_cast</span>&lt;D*&gt;(pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>pb</code> 实际指向类型 <code>D</code> 或者 <code>pd == 0</code>，那么 <code>pd1</code> 和 <code>pd2</code> 将获得相同的值。</p>
<p>如果 <code>pb</code> 实际指向类型 <code>B</code>，那么 <code>dynamic_cast</code> 会返回 <code>0</code>。但是 <code>static_cast</code> 依赖于 <code>expression</code> 认定 <code>pb</code> 指向 <code>D</code> 类型对象，于是简单的返回 <code>D</code> 类型的指针。</p>
<p>结果就是，<code>static_cast</code> 转换会继续执行，但其返回结果是未定义的。这就需要调用者去进一步验证转换结果是有效的。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/casting?view=msvc-160">https://docs.microsoft.com/en-us/cpp/cpp/casting?view=msvc-160</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的智能指针-基础</title>
    <url>/2021/02/18/cplusplus/smart-pointer/</url>
    <content><![CDATA[<h2 id="要点回顾"><a href="#要点回顾" class="headerlink" title="要点回顾"></a>要点回顾</h2><blockquote>
<p>此部分方便知识点快速回顾，首次阅读请从引言部分开始。</p>
</blockquote>
<ul>
<li><p><em>RAII</em> 的主要原则就是把任何在堆上分配的资源(比如动态分配的内存或者系统对象的处理)的所有权提供给在栈上分配的对象(其析构函数包含释放资源及相关清理的代码)。</p>
</li>
<li><p>在现代 C++ 中，原始指针只用于包含在局部作用域，循环或者工具函数的小块代码中(对性能有要求，并且对资源的所有权也不容易混淆)。</p>
</li>
<li><p>智能指针通常提供了获取原始指针的方式。 C++ 标准库中的智能指针包含了成员函数 <code>get</code> 来获取原始指针。</p>
</li>
</ul>
<span id="more"></span>

<h3 id="unique-ptr-vs-shared-ptr-vs-weak-ptr"><a href="#unique-ptr-vs-shared-ptr-vs-weak-ptr" class="headerlink" title="unique_ptr vs shared_ptr vs weak_ptr"></a><code>unique_ptr</code> vs <code>shared_ptr</code> vs <code>weak_ptr</code></h3><blockquote>
<ul>
<li><p><code>unique_ptr</code><br/></p>
<ul>
<li>对封装的原始指针是独占的</li>
<li>默认用于 POCO，除非你明确的知道你需要一个 <code>shared_ptr</code></li>
<li>可以移入新的所有者，但不能拷贝或者共享</li>
<li>替代 <code>auto_ptr</code>，<code>auto_ptr</code> 已作废</li>
<li>对比 <code>boost::scoped_ptr</code>，<code>unique_ptr</code> 更加小巧和高效</li>
<li>长度为一个指针的大小，并且支持右值引用来快速执行 C++ 标准库容器的插入和遍历操作</li>
</ul>
</li>
<li><p><code>shared_ptr</code><br/></p>
<ul>
<li>引用计数智能指针</li>
<li>当你需要将原始指针分派给多个所有者时使用，例如，当你从容器返回一个指针的拷贝并且想要保留它</li>
<li>原始指针不会被 <strong><code>delete</code></strong> 直到<strong>所有的</strong> <code>shared_ptr</code> 超出作用域或者放弃所有权。</li>
<li>长度为两个指针的大小，一个用于对象，另一个用于包含引用计数的共享控制块</li>
</ul>
</li>
<li><p><code>weak_ptr</code><br/></p>
<ul>
<li>结合 <code>shared_ptr</code> 使用的特殊智能指针。</li>
<li><code>weak_ptr</code> 提供了对被一个或者多个 <code>shared_ptr</code> 所拥有的对象的访问，但不参与引用计数。</li>
<li>如果你想要监测某个对象，不要求其不被释放，可以使用 <code>weak_ptr</code></li>
<li>在某些情况下，用于解决 <code>shared_ptr</code> 实例间的循环引用。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在现代 C++ 编程中，标准库包含了智能指针(Smart pointers)。</p>
<p>智能指针用来确保程序不会出现内存和资源的泄漏，并且是”异常安全”(exception-safe)的。</p>
<h2 id="智能指针的使用"><a href="#智能指针的使用" class="headerlink" title="智能指针的使用"></a>智能指针的使用</h2><p>智能指针定义在头文件 <code>memory</code> 里的命名空间 <strong><code>std</code></strong> 中。它对于<em>资源获取即初始化(RAII, Resource Acquisition Is Initialization)</em> 编程理念至关重要。该理念的目的是保证对象初始化的时候也是资源获取的时候，从而使对象的所有资源在单行代码中创建。</p>
<p>实践中，<em>RAII</em> 的主要原则就是把任何在堆上分配的资源(比如动态分配的内存或者系统对象的处理)的所有权提供给在栈上分配的对象(其析构函数包含释放资源及相关清理的代码)。</p>
<p>大多数时候，当你初始化一个原始指针或者资源句柄使其指向实际的资源时，立即将其传给智能指针。</p>
<p>在现代 C++ 中，原始指针只用于包含在局部作用域，循环或者工具函数的小块代码中(对性能有要求，并且对资源的所有权也不容易混淆)。</p>
<p><strong>原始指针和智能指针的声明比较如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseRawPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Using a raw pointer -- not recommended.</span></span><br><span class="line">    Song* pSong = <span class="keyword">new</span> <span class="built_in">Song</span>(<span class="string">L&quot;Nothing on You&quot;</span>, <span class="string">L&quot;Bruno Mars&quot;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use pSong...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t forget to delete!</span></span><br><span class="line">    <span class="keyword">delete</span> pSong;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseSmartPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Declare a smart pointer on stack and pass it the raw pointer.</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Song&gt; <span class="title">song2</span><span class="params">(<span class="keyword">new</span> Song(<span class="string">L&quot;Nothing on You&quot;</span>, <span class="string">L&quot;Bruno Mars&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use song2...</span></span><br><span class="line">    wstring s = song2-&gt;duration_;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// song2 is deleted automatically here.</span></span><br></pre></td></tr></table></figure>

<p>如上所示，智能指针是一个在栈上声明的类模板，并由指向分配在堆上的对象的原始指针初始化。当智能指针初始化后，它就拥有了原始指针的所有权。这意味着智能指针需要负责原始指针指向的内存释放。智能指针的析构函数包含了 <strong><code>delete</code></strong> 的调用，并且由于智能指针是在栈上声明的，其析构函数会在智能指针对象离开作用域时被调用，即使在栈中发生了异常。</p>
<p>通过使用指针运算符(<code>-&gt;</code> 和 <code>*</code>)访问被封装的指针，智能指针类重载了这些运算符以返回被封装的原始指针。</p>
<p>C++ 智能指针的理念类似于在 C# 语言中创建对象的过程：创建对象后让系统负责在正确的时间将其删除。不同之处在于，没有独立的垃圾回收器运行于后台；内存是按照标准 C++ 规范对内存进行管理的，使运行时环境更加快速和高效。</p>
<blockquote>
<p>[!重要]<br/><br>总是在单独的行上创建智能指针，而不是在参数列表中，从而避免由于特定的参数列表分配规则出现一些轻微的内存泄漏</p>
</blockquote>
<p>以下示例显示了 C++ 标准库中的 <code>unique_ptr</code> 是如何封装指向大型对象的指针的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessLargeObject</span><span class="params">(<span class="keyword">const</span> LargeObject&amp; lo)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmartPointerDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// Create the object and pass it to a smart pointer</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;LargeObject&gt; <span class="title">pLarge</span><span class="params">(<span class="keyword">new</span> LargeObject())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Call a method on the object</span></span><br><span class="line">    pLarge-&gt;<span class="built_in">DoSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass a reference to a method.</span></span><br><span class="line">    <span class="built_in">ProcessLargeObject</span>(*pLarge);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//pLarge is deleted automatically when function block goes out of scope.</span></span><br></pre></td></tr></table></figure>
<p>上述示例演示了使用智能指针的关键步骤：</p>
<ol>
<li>将智能指针声明为局部变量(不要在智能指针上使用 <strong><code>new</code></strong> 或者 <code>malloc</code> 表达式)。</li>
<li>在类型参数上，指定被封装指针指向的对象类型。</li>
<li>将指向由 <strong><code>new</code></strong> 创建的对象的指针传给智能指针的构造函数。</li>
<li>使用重载的操作符 <code>-&gt;</code> 和 <code>*</code> 来访问对象。</li>
<li>让智能指针来 <strong><code>delete</code></strong> 对象。</li>
</ol>
<p>智能指针在设计上兼顾了内存和性能的高效性。例如，<code>unique_ptr</code> 唯一的数据成员是被封装的原始指针，这意味着 <code>unique_ptr</code> 具有原始指针同样地大小，4 字节或者 8 字节。通过智能指针重载的操作符 <code>-&gt;</code> 和 <code>*</code> 来访问并不比直接使用原始指针来访问慢多少。</p>
<p>智能指针有其自己的成员函数，通过 <code>.</code> 来访问。例如，一些 C++ 标准库的智能指针有用于重置的成员函数来释放对原始指针的所有权。这可以用于在智能指针超出作用域前释放智能指针管理的内存，看下面的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmartPointerDemo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create the object and pass it to a smart pointer</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;LargeObject&gt; <span class="title">pLarge</span><span class="params">(<span class="keyword">new</span> LargeObject())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Call a method on the object</span></span><br><span class="line">    pLarge-&gt;<span class="built_in">DoSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free the memory before we exit function block.</span></span><br><span class="line">    pLarge.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do some other work...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>智能指针通常提供了获取原始指针的方式。 C++ 标准库中的智能指针包含了成员函数 <code>get</code> 来获取原始指针。 <code>CComPtr</code> 有公共的类成员 <code>p</code>。通过获取原始指针，你能够使用智能指针来管理你自己代码涉及的内存并依然能够将原始指针传递给不支持智能指针的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmartPointerDemo4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create the object and pass it to a smart pointer</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;LargeObject&gt; <span class="title">pLarge</span><span class="params">(<span class="keyword">new</span> LargeObject())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Call a method on the object</span></span><br><span class="line">    pLarge-&gt;<span class="built_in">DoSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass raw pointer to a legacy API</span></span><br><span class="line">    <span class="built_in">LegacyLargeObjectFunction</span>(pLarge.<span class="built_in">get</span>());    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="智能指针的种类"><a href="#智能指针的种类" class="headerlink" title="智能指针的种类"></a>智能指针的种类</h2><p>以下部分总结了在 Windows 环境下不同种类的智能指针，以及如何使用它们。</p>
<h3 id="C-标准库中的智能指针"><a href="#C-标准库中的智能指针" class="headerlink" title="C++ 标准库中的智能指针"></a>C++ 标准库中的智能指针</h3><p>优先使用下列智能指针来封装原始指针指向的纯旧对象(plain old C++ objects，POCO):</p>
<ul>
<li><p><code>unique_ptr</code><br/></p>
<ul>
<li>对封装的原始指针是独占的</li>
<li>默认用于 POCO，除非你明确的知道你需要一个 <code>shared_ptr</code></li>
<li>可以移入新的所有者，但不能拷贝或者共享</li>
<li>替代 <code>auto_ptr</code>，<code>auto_ptr</code> 已作废</li>
<li>对比 <code>boost::scoped_ptr</code>，<code>unique_ptr</code> 更加小巧和高效</li>
<li>长度为一个指针的大小，并且支持右值引用来快速执行 C++ 标准库容器的插入和遍历操作</li>
</ul>
</li>
<li><p><code>shared_ptr</code><br/></p>
<ul>
<li>引用计数智能指针</li>
<li>当你需要将原始指针分派给多个所有者时使用，例如，当你从容器返回一个指针的拷贝并且想要保留它</li>
<li>原始指针不会被 <strong><code>delete</code></strong> 直到<strong>所有的</strong> <code>shared_ptr</code> 超出作用域或者放弃所有权。</li>
<li>长度为两个指针的大小，一个用于对象，另一个用于包含引用计数的共享控制块</li>
</ul>
</li>
<li><p><code>weak_ptr</code><br/></p>
<ul>
<li>结合 <code>shared_ptr</code> 使用的特殊智能指针。</li>
<li><code>weak_ptr</code> 提供了对被一个或者多个 <code>shared_ptr</code> 所拥有的对象的访问，但不参与引用计数。</li>
<li>如果你想要监测某个对象，不要求其不被释放，可以使用 <code>weak_ptr</code></li>
<li>在某些情况下，用于解决 <code>shared_ptr</code> 实例间的循环引用。</li>
</ul>
</li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>用于 COM 组件的智能指针</li>
<li>用于 POCO对象的ATL智能指针</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>Microsoft Docs (<a href="https://docs.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-160">https://docs.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-160</a>)</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>new 和 delete 运算符</title>
    <url>/2021/02/10/cplusplus/keyword-new-delete/</url>
    <content><![CDATA[<p>C++ 支持使用操作符 <strong><code>new</code></strong> 和 <strong><code>delete</code></strong> 来动态分配和释放对象。</p>
<p><strong><code>new</code></strong> 运算符调用特殊函数 <strong><code>operator new</code><strong>，</strong><code>delete</code></strong> 运算符调用特殊函数 **<code>operator delete</code>**。</p>
<p>如果 <strong><code>new</code></strong> 分配内存失败，异常 <code>std::bad_alloc</code>会被抛出。</p>
<span id="more"></span>

<p><strong>可以如下测试内存分配失败的情况：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG_NUMBER 100000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> *pI = <span class="keyword">new</span> <span class="keyword">int</span>[BIG_NUMBER];</span><br><span class="line">   <span class="keyword">if</span>( pI == <span class="number">0x0</span> ) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Insufficient memory&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <strong><code>new</code></strong> 操作符动态分配的内存可以通过 <strong><code>delete</code></strong> 操作符进行释放。<br><strong><code>delete</code></strong> 操作符会触发调用类的析构函数(如果有的话)。</p>
<p>**以下示例为用户自定义的  <strong><code>operator new</code></strong> 和 **<code>operator delete</code><strong>：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fLogMemory = <span class="number">0</span>;      <span class="comment">// Perform logging (0=no; nonzero=yes)?</span></span><br><span class="line"><span class="keyword">int</span> cBlocksAllocated = <span class="number">0</span>;  <span class="comment">// Count of blocks allocated.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User-defined operator new.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="keyword">size_t</span> stAllocateBlock )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> fInOpNew = <span class="number">0</span>;   <span class="comment">// Guard flag.</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ( fLogMemory &amp;&amp; !fInOpNew ) &#123;</span><br><span class="line">      fInOpNew = <span class="number">1</span>;</span><br><span class="line">      clog &lt;&lt; <span class="string">&quot;Memory block &quot;</span> &lt;&lt; ++cBlocksAllocated</span><br><span class="line">          &lt;&lt; <span class="string">&quot; allocated for &quot;</span> &lt;&lt; stAllocateBlock</span><br><span class="line">          &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">      fInOpNew = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">malloc</span>( stAllocateBlock );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User-defined operator delete.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">( <span class="keyword">void</span> *pvMem )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> fInOpDelete = <span class="number">0</span>;   <span class="comment">// Guard flag.</span></span><br><span class="line">   <span class="keyword">if</span> ( fLogMemory &amp;&amp; !fInOpDelete ) &#123;</span><br><span class="line">      fInOpDelete = <span class="number">1</span>;</span><br><span class="line">      clog &lt;&lt; <span class="string">&quot;Memory block &quot;</span> &lt;&lt; cBlocksAllocated--</span><br><span class="line">          &lt;&lt; <span class="string">&quot; deallocated\n&quot;</span>;</span><br><span class="line">      fInOpDelete = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>( pvMem );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">   fLogMemory = <span class="number">1</span>;   <span class="comment">// Turn logging on</span></span><br><span class="line">   <span class="keyword">if</span>( argc &gt; <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">atoi</span>( argv[<span class="number">1</span>] ); ++i ) &#123;</span><br><span class="line">         <span class="keyword">char</span> *pMem = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">         <span class="keyword">delete</span>[] pMem;</span><br><span class="line">      &#125;</span><br><span class="line">   fLogMemory = <span class="number">0</span>;  <span class="comment">// Turn logging off.</span></span><br><span class="line">   <span class="keyword">return</span> cBlocksAllocated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码可以用来检测内存泄漏，重新定义全局操作符 <strong><code>new</code></strong> 和 <strong><code>delete</code></strong> 来计算内存的分配和释放次数。</p>
<p>编译器支持在类中声明成员数组 <strong><code>new</code></strong> 和 <strong><code>delete</code></strong> 操作符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>  &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="keyword">size_t</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[] (<span class="keyword">void</span>*) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   X *pX = <span class="keyword">new</span> X[<span class="number">5</span>];</span><br><span class="line">   <span class="keyword">delete</span> [] pX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>const 和 volatile 指针</title>
    <url>/2021/02/10/cplusplus/const-and-volatile-pointer/</url>
    <content><![CDATA[<p>关键字 <strong><code>const</code></strong> 和 <strong><code>volatile</code></strong> 规定了指针的处理方式：</p>
<ul>
<li><p><strong><code>const</code></strong> 规定指针在初始化后是受保护的，不能够再修改。</p>
</li>
<li><p><strong><code>volatile</code></strong> 规定了变量的值能够被用户应用程序外部的操作所修改。</p>
</li>
</ul>
<p>因此，关键字 <strong><code>volatile</code></strong> 可以声明共享内存中的对象来和中断服务例程进行通信。共享内存可以被多个进程或者全局数据块使用。</p>
<span id="more"></span>


<p>每次程序调用声明为 <strong><code>volatile</code></strong> 的变量时，编译器将会从内存中重新读取值。这显著缩小了可能的优化空间。然而，当对象的状态能够发生非预期的变化时，这是保证程序正常运行的唯一方法。</p>
<p>**声明指针为 <strong><code>const</code></strong> 或 **<code>volatile</code><strong>：</strong></p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cpch;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span> *vpch;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>声明指针的值为 <strong><code>const</code></strong> 或 **<code>volatile</code>**：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> pchc;</span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">volatile</span> pchv;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><em>const 指针的用法已经在 “C++ 中的 const 关键字” 中举例说明，此处不再赘述。</em></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>原始指针 [raw pointers]</title>
    <url>/2021/02/10/cplusplus/raw-pointer/</url>
    <content><![CDATA[<p>指针是一个<strong>变量</strong>，用于存储对象的内存<strong>地址</strong>。<br>指针广泛应用于 C 和 C++：</p>
<blockquote>
<ul>
<li>在堆上分配新对象</li>
<li>通过参数将某些函数传递给其他函数</li>
<li>迭代/遍历数组或其他数据结构的元素</li>
</ul>
</blockquote>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="literal">nullptr</span>; <span class="comment">// declare pointer and initialize it</span></span><br><span class="line">                  <span class="comment">// so that it doesn&#x27;t store a random address</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">p = &amp;i; <span class="comment">// assign pointer to address of object</span></span><br><span class="line"><span class="keyword">int</span> j = *p; <span class="comment">// dereference p to retrieve the value at its address</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass* mc = <span class="keyword">new</span> <span class="built_in">MyClass</span>(); <span class="comment">// allocate object on the heap</span></span><br><span class="line">mc-&gt;<span class="built_in">print</span>(); <span class="comment">// access class member</span></span><br><span class="line"><span class="keyword">delete</span> mc; <span class="comment">// delete object (please don&#x27;t forget!)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// declare a C-style string. Compiler adds terminating &#x27;\0&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* pconst = &amp;c; <span class="comment">// declare a non-const pointer to const int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c2 = <span class="number">2</span>;</span><br><span class="line">pconst = &amp;c2;  <span class="comment">// OK pconst itself isn&#x27;t const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> pconst2 = &amp;c;</span><br><span class="line"><span class="comment">// pconst2 = &amp;c2; // Error! pconst2 is const.</span></span><br></pre></td></tr></table></figure>

<p>当定义函数时，尽量将指针参数标记为 <strong><code>const</code><strong>，除非你期望函数能够修改传入的对象。一般来讲，</strong><code>const</code></strong> 引用更适合用来传递对象给函数，除非对象可能为 **<code>nullptr</code>**。</p>
<p>函数指针使函数能够被传递给其他函数，在 C 风格代码中可用于回调。现代 C++ 使用 lambda 表达式来达到同样地目的。</p>
<p><strong>C 风格代码示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; num &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accepts a MyClass pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_A</span><span class="params">(MyClass* mc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Modify the object that mc points to.</span></span><br><span class="line">    <span class="comment">// All copies of the pointer will point to</span></span><br><span class="line">    <span class="comment">// the same modified object.</span></span><br><span class="line">    mc-&gt;num = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accepts a MyClass object</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_B</span><span class="params">(MyClass mc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mc here is a regular object, not a pointer.</span></span><br><span class="line">    <span class="comment">// Use the &quot;.&quot; operator to access members.</span></span><br><span class="line">    <span class="comment">// This statement modifies only the local copy of mc.</span></span><br><span class="line">    mc.num = <span class="number">21</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Local copy of mc:&quot;</span>;</span><br><span class="line">    mc.<span class="built_in">print</span>(); <span class="comment">// &quot;Erika, 21&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Use the * operator to declare a pointer type</span></span><br><span class="line">    <span class="comment">// Use new to allocate and initialize memory</span></span><br><span class="line">    MyClass* pmc = <span class="keyword">new</span> MyClass&#123; <span class="number">108</span>, <span class="string">&quot;Nick&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prints the memory address. Usually not what you want.</span></span><br><span class="line">    std:: cout &lt;&lt; pmc &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the pointed-to object by dereferencing the pointer</span></span><br><span class="line">    <span class="comment">// to access the contents of the memory location.</span></span><br><span class="line">    <span class="comment">// mc is a separate object, allocated here on the stack</span></span><br><span class="line">    MyClass mc = *pmc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Declare a pointer that points to mc using the addressof operator</span></span><br><span class="line">    MyClass* pcopy = &amp;mc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the -&gt; operator to access the object&#x27;s public members</span></span><br><span class="line">    pmc-&gt;<span class="built_in">print</span>(); <span class="comment">// &quot;Nick, 108&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the pointer. Now pmc and pmc2 point to same object!</span></span><br><span class="line">    MyClass* pmc2 = pmc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use copied pointer to modify the original object</span></span><br><span class="line">    pmc2-&gt;name = <span class="string">&quot;Erika&quot;</span>;</span><br><span class="line">    pmc-&gt;<span class="built_in">print</span>(); <span class="comment">// &quot;Erika, 108&quot;</span></span><br><span class="line">    pmc2-&gt;<span class="built_in">print</span>(); <span class="comment">// &quot;Erika, 108&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass the pointer to a function.</span></span><br><span class="line">    <span class="built_in">func_A</span>(pmc);</span><br><span class="line">    pmc-&gt;<span class="built_in">print</span>(); <span class="comment">// &quot;Erika, 3&quot;</span></span><br><span class="line">    pmc2-&gt;<span class="built_in">print</span>(); <span class="comment">// &quot;Erika, 3&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dereference the pointer and pass a copy</span></span><br><span class="line">    <span class="comment">// of the pointed-to object to a function</span></span><br><span class="line">    <span class="built_in">func_B</span>(*pmc);</span><br><span class="line">    pmc-&gt;<span class="built_in">print</span>(); <span class="comment">// &quot;Erika, 3&quot; (original not modified by function)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">delete</span></span>(pmc); <span class="comment">// don&#x27;t forget to give memory back to operating system!</span></span><br><span class="line">   <span class="comment">// delete(pmc2); //crash! memory location was already deleted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针算法和数组"><a href="#指针算法和数组" class="headerlink" title="指针算法和数组"></a>指针算法和数组</h2><p>指针和数组是紧密联系的，当一个数组以值传递给函数时，传递的是指向第一个元素的指针，下面的示例演示了指针和数组的重要属性：</p>
<ul>
<li><strong><code>sizeof</code></strong> 操作符返回数组以字节为单位的大小。</li>
<li>要确定元素的个数，可以用元素的大小值去除数组的总大小。</li>
<li>当数组传递给函数时，将退化为指针类型。</li>
<li><strong><code>sizeof</code></strong> 操作符用在指针上时返回时指针的大小，在 x86 系统上是4字节，在 x64 系统上是8字节。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// returns pointer size. not useful here.</span></span><br><span class="line">    <span class="keyword">size_t</span> test = <span class="built_in"><span class="keyword">sizeof</span></span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i[<span class="number">5</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// sizeof(i) = total bytes</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="built_in"><span class="keyword">sizeof</span></span>(i) / <span class="built_in"><span class="keyword">sizeof</span></span>(i[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">func</span>(i,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非 <strong><code>const</code></strong> 指针可以进行算术操作以指向不同的内存地址: <strong>++</strong>, <strong>+=</strong>, <strong>-=</strong> and **–**。</p>
<p>这对于数组尤其是无类型的缓冲区特别有用: </p>
<ul>
<li><strong>void*</strong> 以一个 <strong><code>char</code></strong> (1 byte)的大小递增。</li>
<li>有类型的指针以类型的大小递增。</li>
</ul>
<p>以下示例演示了指针如何通过算数操作 Windows 位图的像素点。<br>注意 <strong><code>new</code></strong> 和 <strong><code>delete</code></strong> 的使用，以及解引用操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    BITMAPINFOHEADER header;</span><br><span class="line">    header.biHeight = <span class="number">100</span>; <span class="comment">// Multiple of 4 for simplicity.</span></span><br><span class="line">    header.biWidth = <span class="number">100</span>;</span><br><span class="line">    header.biBitCount = <span class="number">24</span>;</span><br><span class="line">    header.biPlanes = <span class="number">1</span>;</span><br><span class="line">    header.biCompression = BI_RGB;</span><br><span class="line">    header.biSize = <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFOHEADER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> bufferSize = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* buffer = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[bufferSize];</span><br><span class="line"></span><br><span class="line">    BITMAPFILEHEADER bf;</span><br><span class="line">    bf.bfType = <span class="number">0x4D42</span>;</span><br><span class="line">    bf.bfSize = header.biSize + <span class="number">14</span> + bufferSize;</span><br><span class="line">    bf.bfReserved1 = <span class="number">0</span>;</span><br><span class="line">    bf.bfReserved2 = <span class="number">0</span>;</span><br><span class="line">    bf.bfOffBits = <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPFILEHEADER) + <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFOHEADER); <span class="comment">//54</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a gray square with a 2-pixel wide outline.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* begin = &amp;buffer[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* end = &amp;buffer[<span class="number">0</span>] + bufferSize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* p = begin;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> pixelWidth = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> borderWidth = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// Is top or bottom edge?</span></span><br><span class="line">        <span class="keyword">if</span> ((p &lt; begin + header.biWidth * pixelWidth * borderWidth)</span><br><span class="line">            || (p &gt; end - header.biWidth * pixelWidth * borderWidth)</span><br><span class="line">            <span class="comment">// Is left or right edge?</span></span><br><span class="line">            || (p - begin) % (header.biWidth * pixelWidth) &lt; (borderWidth * pixelWidth)</span><br><span class="line">            || (p - begin) % (header.biWidth * pixelWidth) &gt; ((header.biWidth - borderWidth) * pixelWidth))</span><br><span class="line">        &#123;</span><br><span class="line">            *p = <span class="number">0x0</span>; <span class="comment">// Black</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *p = <span class="number">0xC3</span>; <span class="comment">// Gray</span></span><br><span class="line">        &#125;</span><br><span class="line">        p++; <span class="comment">// Increment one byte sizeof(unsigned char).</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ofstream <span class="title">wf</span><span class="params">(<span class="string">R&quot;(box.bmp)&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">    wf.<span class="built_in">write</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;bf), <span class="built_in"><span class="keyword">sizeof</span></span>(bf));</span><br><span class="line">    wf.<span class="built_in">write</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;header), <span class="built_in"><span class="keyword">sizeof</span></span>(header));</span><br><span class="line">    wf.<span class="built_in">write</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(begin), bufferSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] buffer; <span class="comment">// Return memory to the OS.</span></span><br><span class="line">    wf.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h2><p><strong><code>void</code></strong> 指针指向原始内存地址。有时需要使用 void* 指针，例如在 C++ 代码和 C 函数之间传递时。</p>
<p>当有类型的指针转换为 <strong><code>void</code></strong> 指针时，保存的内存地址是不变的。然而，类型信息会丢失，所以你不能进行加减操作。内存地址是可以转型(cast)的，例如，从 <code>MyClass*</code> 到 <strong><code>void*</code></strong> 然后回到 <code>MyClass*</code>。</p>
<p>这样的操作本身就是容易出错的，必须很谨慎。现代 C++ 几乎在所有场景中都不建议使用 <strong><code>void</code></strong> 指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//func.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>* data, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* c = (<span class="keyword">char</span>*)(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill in the buffer with data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        *c = <span class="number">0x41</span>;</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>* data, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; num &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass* mc = <span class="keyword">new</span> MyClass&#123;<span class="number">10</span>, <span class="string">&quot;Marian&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span>* p = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(mc);</span><br><span class="line">    MyClass* mc2 = <span class="keyword">static_cast</span>&lt;MyClass*&gt;(p);</span><br><span class="line">    std::cout &lt;&lt; mc2-&gt;name &lt;&lt; std::endl; <span class="comment">// &quot;Marian&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// use operator new to allocate untyped memory block</span></span><br><span class="line">    <span class="keyword">void</span>* pvoid = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">char</span>* pchar = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(pvoid);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span>* c = pchar; c &lt; pchar + <span class="number">1000</span>; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        *c = <span class="number">0x00</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">func</span>(pvoid, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(pvoid)[<span class="number">0</span>];</span><br><span class="line">    std::cout &lt;&lt; ch &lt;&lt; std::endl; <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>C 风格代码中，函数指针主要用来将一个函数传递给另一个函数。这允许调用方可以定制函数的行为而不去修改他。</p>
<p>现代 C++ 中，lambda 表达式提供了同样地功能并保证了更高的安全性和其他优点。</p>
<p>函数指针声明规定了指向的函数必须要有如下签名：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declare pointer to any function that...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...accepts a string and returns a string</span></span><br><span class="line"><span class="built_in">string</span> (*g)(string a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// has no return value and no parameters</span></span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*x)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...returns an int and takes three parameters</span></span><br><span class="line"><span class="comment">// of the specified types</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*i)(<span class="keyword">int</span> i, string s, <span class="keyword">double</span> d);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string base &#123;<span class="string">&quot;hello world&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">append</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base.<span class="built_in">append</span>(<span class="string">&quot; &quot;</span>).<span class="built_in">append</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">prepend</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">append</span>(<span class="string">&quot; &quot;</span>).<span class="built_in">append</span>(base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">combine</span><span class="params">(string s, string(*g)(string a))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*g)(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">combine</span>(<span class="string">&quot;from MSVC&quot;</span>, append) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">combine</span>(<span class="string">&quot;Good morning and&quot;</span>, prepend) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 &quot;= default&quot; 和 &quot;= delete&quot; 函数</title>
    <url>/2021/02/09/cplusplus/keyword-default-delete/</url>
    <content><![CDATA[<p>在 C++ 11 中，**”= default”** 和 <strong>“= delete”</strong> 函数使我们能够显示指定<strong>成员函数</strong>是否自动生成。</p>
<p>其中，**”= delete”** 使我们能够避免<strong>所有函数</strong> (特殊成员函数，普通成员函数和非成员函数) 参数中出现错误的类型提升 (导致非预期的函数调用)。</p>
<blockquote>
<p>C++ 特殊成员函数：<br/><br>即使用户不自定义，编译器也会自动生成的成员函数，包括</p>
<ul>
<li>构造函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值运算符</li>
<li>移动构造函数</li>
<li>移动赋值运算符</li>
<li>析构函数</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="“-default”-函数"><a href="#“-default”-函数" class="headerlink" title="“= default” 函数"></a><strong>“= default”</strong> 函数</h2><p><strong><code>= default</code></strong> 可以用于任何特殊成员函数，比如显示指定特殊成员函数使用默认的函数实现，定义非公有的特殊成员函数，或者在某些情况下恢复特殊成员函数的自动生成。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">widget</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">inline</span> widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> widget&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> widget&amp; widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> widget&amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>你可以在类的外部指定特殊成员函数为 **<code>= default</code>**，只要它是内联的。</p>
<p>由于默认特殊成员函数的性能优势，当需要默认行为时建议使用自动生成的特殊成员函数而不是使用空函数体。为此可以显示指定特殊成员函数为 <strong><code>= default</code></strong> 或者不声明它。</p>
<h2 id="“-delete”-函数"><a href="#“-delete”-函数" class="headerlink" title="“= delete” 函数"></a><strong>“= delete”</strong> 函数</h2><p>定义函数(任何函数)为 <strong><code>= delete</code></strong> 防止其被定义和调用。</p>
<h3 id="防止编译器生成你不需要的特殊成员函数。"><a href="#防止编译器生成你不需要的特殊成员函数。" class="headerlink" title="防止编译器生成你不需要的特殊成员函数。"></a>防止编译器生成你不需要的<strong>特殊</strong>成员函数。</h3><p>和 <strong><code>= default</code><strong>不同，</strong>“= delete”</strong> 函数必须在函数声明的时候指定其为 **<code>= default</code>**， 而不能在之后重新声明其为 **<code>= default</code>**。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// deleted operator new prevents widget from being dynamically allocated.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>防止成员和非成员函数参数发生错误的类型提升导致非预期的函数调用。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deleted overload prevents call through type promotion of float to double from succeeding.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_with_true_double_only</span><span class="params">(<span class="keyword">float</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_with_true_double_only</span><span class="params">(<span class="keyword">double</span> param)</span> </span>&#123; <span class="keyword">return</span>; &#125;</span><br></pre></td></tr></table></figure>


<p>上面这个例子中，通过传递 <strong><code>float</code></strong> 类型参数来调用 <code>call_with_true_double_only</code> 会产生一个编译错误, 但是使用 <strong><code>int</code></strong> 类型参数则不会，**<code>int</code>** 类型的参数会被转换提升为 <strong><code>double</code></strong> 类型， 尽管这不是想要的结果。</p>
<p>为保证任何非 <strong><code>double</code></strong> 参数的调用能够产生编译错误，可以声明一个模板函数并指定其为 **<code>= delete</code>**。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_with_true_double_only</span><span class="params">(T)</span> </span>= <span class="keyword">delete</span>; <span class="comment">//prevent call through type promotion of any T to double from succeeding.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_with_true_double_only</span><span class="params">(<span class="keyword">double</span> param)</span> </span>&#123; <span class="keyword">return</span>; &#125; <span class="comment">// also define for const double, double&amp;, etc. as needed.</span></span><br></pre></td></tr></table></figure>

<h2 id="“-default”-和-“-delete”-函数的优势"><a href="#“-default”-和-“-delete”-函数的优势" class="headerlink" title="“= default” 和 “= delete” 函数的优势"></a><strong>“= default”</strong> 和 <strong>“= delete”</strong> 函数的优势</h2><p>在 C++ 中，如果用户不自定义，编译器可以自动生成特殊成员函数。这对简单类型是方便的，但是复杂类型经常会自定义特殊成员函数，使用 <strong><code>= delete</code></strong> 可以防止这些特殊成员函数被自动创建。</p>
<p>在实践中:</p>
<ul>
<li>如果任何构造函数已经显示声明，那么默认构造函数就不会自动生成。</li>
<li>如果虚析构函数已经显示声明，那么默认西沟函数就不会自动生成。</li>
<li>如果移动构造函数或者移动赋值操作符已经显示声明，那么：<ul>
<li>拷贝构造函数就不会自动生成</li>
<li>拷贝赋值运算符就不会自动生成</li>
</ul>
</li>
<li>如果拷贝构造函数，拷贝赋值操作符，移动构造函数或者移动赋值操作符已经显示声明，那么：<ul>
<li>移动构造函数就不会自动生成</li>
<li>移动赋值运算符就不会自动生成</li>
</ul>
</li>
</ul>
<p><strong>注意:</strong></p>
<blockquote>
<p>C++11 标准还规定了如下规则：</p>
<ul>
<li>如果拷贝构造函数或者析构函数被显示声明，那么拷贝赋值运算符就不会自动生成</li>
<li>如果拷贝赋值运算符或者析构函数被显示声明，那么拷贝构造函数就不会自动生成</li>
</ul>
<p>这两种情况下， Visual Studio 仍然会自动生成必要的函数，并不会产生告警。</p>
</blockquote>
<p>在 C++11 之前，非拷贝类型的通用实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">noncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">noncopyable</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">noncopyable</span>(<span class="keyword">const</span> noncopyable&amp;);</span><br><span class="line">  noncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> noncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码存在一些问题：</p>
<ul>
<li>拷贝构造函数声明为私有导致了默认构造函数无法自动生成，必须显示声明默认构造函数,即使他什么也不做。</li>
<li>即使显示声明的默认构造函数声明也不做，编译器也将其认为是复杂的，其不如自动生产的默认构造函数来的高效，并且 <code>noncopyable</code> 也不会认为是 POD 类型。</li>
<li>即使拷贝构造函数和拷贝赋值运算符被声明为私有的，成员函数和友元仍然能够调用他们，如果他们声明了但未定义，调用会产生链接错误。</li>
<li>尽管这是通用的实现方式，但是其意图并不明显，除非你了解所有特殊成员函数自动生成的规则。</li>
</ul>
<p>在 C++11 中， 非拷贝类型可以以更直接的方式实现从而解决了上述问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">noncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">noncopyable</span>(<span class="keyword">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  noncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的 const 关键字</title>
    <url>/2021/02/09/cplusplus/keyword-const/</url>
    <content><![CDATA[<h2 id="常见用法示例"><a href="#常见用法示例" class="headerlink" title="常见用法示例"></a>常见用法示例</h2><h3 id="变量申明"><a href="#变量申明" class="headerlink" title="变量申明"></a>变量申明</h3><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>const declaration</code></strong></p>
</blockquote>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//E0137: expression must be a modifiable lvalue</span></span><br><span class="line"><span class="comment">//E0144: a value of type &quot;const int *&quot; cannot be used to initialize an entity of type &quot;int *&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const value</span></span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="number">1</span>;                       <span class="comment">//OK</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> var2 = <span class="number">2</span>;                 <span class="comment">//OK</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> var3 = <span class="number">3</span>;                 <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line">    var1 = <span class="number">10</span>;                          <span class="comment">//OK</span></span><br><span class="line">    var2 = <span class="number">10</span>;                          <span class="comment">//E0137</span></span><br><span class="line">    var3 = <span class="number">10</span>;                          <span class="comment">//E0137</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pVar1 = &amp;var1;                 <span class="comment">//OK</span></span><br><span class="line">    <span class="keyword">int</span>* pVar2 = &amp;var2;                 <span class="comment">//E0144</span></span><br><span class="line"></span><br><span class="line">    *pVar1 = <span class="number">20</span>;                        <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span>* pVar3 = &amp;var1;           <span class="comment">//OK</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span>* pVar4 = &amp;var2;           <span class="comment">//OK</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* pVar5 = &amp;var3;           <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line">    *pVar3 = <span class="number">10</span>;                        <span class="comment">//E0137</span></span><br><span class="line">    pVar3 = pVar1;                      <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const ptr</span></span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">const</span> pVar6 = &amp;var1;           <span class="comment">//OK</span></span><br><span class="line">    *pVar6 = <span class="number">20</span>;                        <span class="comment">//OK</span></span><br><span class="line">    pVar6 = pVar1;                      <span class="comment">//E0137</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//const value and const ptr</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span>* <span class="keyword">const</span> pVar7 = &amp;var1;     <span class="comment">//OK</span></span><br><span class="line">    *pVar7 = <span class="number">20</span>;                        <span class="comment">//E0137</span></span><br><span class="line">    pVar7 = pVar1;                      <span class="comment">//E0137</span></span><br></pre></td></tr></table></figure>

<p><strong>补充：对于函数形参，同上。</strong></p>
<br/>

<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>member-function const</code></strong></p>
</blockquote>
<p>声明成员函数为 <code>const</code> 意味着该函数被禁止修改调用它的对象，包括：</p>
<ul>
<li>无法修改任何非静态的数据成员</li>
<li>调用任何非静态成员函数。</li>
</ul>
<p>关键字 <code>const</code> 必须同时标记到声明和实现。</p>
<p>非类成员函数无法声明为 <code>const</code>。</p>
<h2 id="C-and-C-const-的区别"><a href="#C-and-C-const-的区别" class="headerlink" title="C and C++ const 的区别"></a>C and C++ const 的区别</h2><p>当在 C 源码中声明 <code>const</code> 变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>在其他模块中使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure>

<p>同样的行为在 C++ 源码中定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>如果想要在 C 模块中调用 C++ 模块的变量，那么需要在 C++ 中按如下定义变量以防止名称被 C++ 编译器破坏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h2 id="使用-const-的场景"><a href="#使用-const-的场景" class="headerlink" title="使用 const 的场景"></a>使用 const 的场景</h2><p>只要允许，尽可能地使用 <code>const</code>，更进一步，尽可能使用 <code>constexpr</code>。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>constexpr 的来龙去脉</title>
    <url>/2021/02/09/cplusplus/what-is-constexpr/</url>
    <content><![CDATA[<h2 id="要点回顾"><a href="#要点回顾" class="headerlink" title="要点回顾"></a>要点回顾</h2><blockquote>
<p>此部分方便知识点快速回顾，首次阅读请从引言部分开始。</p>
</blockquote>
<ul>
<li><p>所有的 <strong><code>constexpr</code></strong> 对象都是 <strong><code>const</code></strong> 的，但不是所有的 <strong><code>const</code></strong> 对象都是 <strong><code>constexpr</code></strong> 的。</p>
</li>
<li><p><strong><code>constexpr</code></strong> 整型值能够用在任何 <strong><code>const</code></strong> 整型值可以用的地方，例如模板参数和数组的申明。</p>
</li>
<li><p>不同于 **<code>const</code>**， <strong><code>constexpr</code></strong> 还可以修饰函数和类的构造函数。 </p>
</li>
<li><p><strong><code>constexpr</code></strong> 表示值或者返回值是常量，并且如果可能，在编译时计算它们。</p>
</li>
<li><p><strong><code>constexpr</code></strong> 和 <strong><code>const</code></strong> 的主要区别是 <strong><code>const</code></strong> 变量的初始化可以被延时到运行时，而 <strong><code>constexpr</code></strong> 变量必须在编译时初始化。</p>
</li>
<li><p>当参数是 <strong><code>constexpr</code></strong> 值时，**<code>constexpr</code>** 函数产生一个编译时的常量。当被调用时传入非 <strong><code>constexpr</code></strong> 参数，或者其返回值在非编译时请求，**<code>constexpr</code>** 函数和普通函数一样将产生一个运行时的值。(这种行为能够让你避免编写两个相同功能的函数，一个为 <strong><code>constexpr</code></strong> 版本，一个为非 <strong><code>constexpr</code></strong> 版本)</p>
</li>
<li><p><strong><code>constexpr</code></strong> 是对象或者函数接口的一部分，所以如果你使用了 <strong><code>constexpr</code></strong> 但反悔了，移除 <strong><code>constexpr</code></strong> 可能会导致大量的调用代码编译失败。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>关键字 <strong><code>constexpr</code></strong> (<em>constant expression</em>) 是在 C++11 中引入的，并且在 C++14 中进行了优化。</p>
<h2 id="constexpr-是什么？"><a href="#constexpr-是什么？" class="headerlink" title="constexpr 是什么？"></a>constexpr 是什么？</h2><p><strong><code>constexpr</code></strong> 和 <strong><code>const</code></strong> 一样可以用来修饰变量：试图修改 <strong><code>constexpr</code></strong> 变量时，编译器将会报错。</p>
<p>不同于 **<code>const</code>**， <strong><code>constexpr</code></strong> 还可以修饰函数和类的构造函数。 <strong><code>constexpr</code></strong> 表示值或者返回值是常量，并且如果可能，在编译时计算它们。</p>
<p>一个 <strong><code>constexpr</code></strong> 整型值能够用在任何 <strong><code>const</code></strong> 整型值可以用的地方，例如模板参数和数组的申明。</p>
<p>当值在编译时计算而不是运行时计算时，它能够使程序运行得更快，并使用更少的内存。</p>
<p>为了限制编译时常量计算的复杂性，以及其对编译时间潜在的影响， C++14 标准需要 <strong><code>constexpr</code></strong> 类型必须为字面值类型。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote>
<p><strong><code>constexpr</code></strong> <em>literal-type</em> <em>identifier</em> <strong>=</strong> <em>constant-expression</em> **;**<br><strong><code>constexpr</code></strong> <em>literal-type</em> <em>identifier</em> <strong>{</strong> <em>constant-expression</em> <strong>}</strong> **;**<br><strong><code>constexpr</code></strong> <em>literal-type</em> <em>identifier</em> <strong>(</strong> <em>params</em> <strong>)</strong> **;**<br><strong><code>constexpr</code></strong> <em>ctor</em> <strong>(</strong> <em>params</em> <strong>)</strong> <strong>;</strong></p>
</blockquote>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><em>params</em><br>一个或者多个参数, 每个参数必须是字面值类型并且本身是 <strong>常量表达式</strong> 。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>一个 <strong><code>constexpr</code></strong> 变量或者函数必须返回字面值类型。</p>
<h3 id="constexpr-变量"><a href="#constexpr-变量" class="headerlink" title="constexpr 变量"></a><strong><code>constexpr</code></strong> 变量</h3><p><strong><code>constexpr</code></strong> 和 <strong><code>const</code></strong> 的主要区别是 <strong><code>const</code></strong> 变量的初始化可以被延时到运行时，而 <strong><code>constexpr</code></strong> 变量必须在编译时初始化。所有的 <strong><code>constexpr</code></strong> 变量都是 **<code>const</code>**。</p>
<ul>
<li><p>当变量由字面值类型初始化时，能够声明为 **<code>constexpr</code>**。如果初始化时由构造函数执行的，那么该构造函数也必须声明为 **<code>constexpr</code>**。</p>
</li>
<li><p>引用类型可以声明为 <strong><code>constexpr</code></strong> 只要满足：引用对象是由 常量表达式初始化的，并且初始化时任何隐式转换也是常量表达式。</p>
</li>
<li><p>所有 <strong><code>constexpr</code></strong> 变量或者函数的声明必须拥有 <strong><code>constexpr</code></strong> 说明符。</p>
</li>
</ul>
<p><strong>举例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">float</span> x = <span class="number">42.0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">float</span> y&#123;<span class="number">108</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">float</span> z = <span class="built_in">exp</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> i; <span class="comment">// Error! Not initialized</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> k = j + <span class="number">1</span>; <span class="comment">//Error! j not a constant expression</span></span><br></pre></td></tr></table></figure>

<h3 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a><strong><code>constexpr</code></strong> 函数</h3><p><strong><code>constexpr</code></strong> 函数的返回值是在编译时计算的。调用代码需要返回值在编译时初始化一个 <strong><code>constexpr</code></strong> 变量， 或者提供一个非类型模板参数。 当参数是 <strong><code>constexpr</code></strong> 值时，**<code>constexpr</code>** 函数产生一个编译时的常量。当被调用时传入非 <strong><code>constexpr</code></strong> 参数，或者其返回值在非编译时请求，**<code>constexpr</code>** 函数和普通函数一样将产生一个运行时的值。(这种行为能够让你避免编写两个相同功能的函数，一个为 <strong><code>constexpr</code></strong> 版本，一个为非 <strong><code>constexpr</code></strong> 版本)</p>
<p><strong><code>constexpr</code></strong> 函数或者构造函数默认是 <strong><code>inline</code></strong> 的.</p>
<p>以下规则适用于 <strong><code>constexpr</code></strong> 函数:</p>
<ul>
<li>必须接受并返回字面值类型。</li>
<li>可以是递归的.</li>
<li>不能是虚构的。当类有虚基类时，构造函数不能定义为 **<code>constexpr</code>**。</li>
<li>函数体可以定义为 <code>= default</code> 或者 <code>= delete</code>。</li>
<li>函数体不能包含 <strong><code>goto</code></strong> 语句或者 <strong><code>try</code></strong> 块。</li>
<li>显式特化/具体化(explicit specialization)的非 <strong><code>constexpr</code></strong> 模板能够声明为 **<code>constexpr</code>**。</li>
<li>显式特化/具体化(explicit specialization)的非 <strong><code>constexpr</code></strong> 模板不必声明为 **<code>constexpr</code>**。</li>
</ul>
<p>以下 <strong><code>constexpr</code></strong> 函数规则适用于 Visual Studio 2017 及以后的版本：</p>
<ul>
<li>可以包含 <strong><code>if</code></strong> 和 <strong><code>switch</code></strong> 语句，以及所有循环语句包括 <strong><code>for</code><strong>，</strong><code>while</code></strong> 和 <strong>do-while</strong></li>
<li>可以包含初始化的局部变量，并且必须是字面值类型，不能是 <strong><code>static</code></strong> 或者 thread-local。该局部变量不必是 <strong><code>const</code></strong> 的。</li>
<li>非 <strong><code>static</code></strong> 的 <strong><code>constexpr</code></strong> 成员函数不必隐式为 <strong><code>const</code></strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">float</span> <span class="title">exp</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> :</span><br><span class="line">        n % <span class="number">2</span> == <span class="number">0</span> ? <span class="built_in">exp</span>(x * x, n / <span class="number">2</span>) :</span><br><span class="line">        <span class="built_in">exp</span>(x * x, (n - <span class="number">1</span>) / <span class="number">2</span>) * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
<p>在 Visual Studio 调试器中, 当调试一个非优化的调试版本，你能够通过在函数内部设置断点来区分 <strong><code>constexpr</code></strong> 函数是否在编译时计算。如果断点能够触发，则为运行时计算，否则，为编译时计算。</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下例子演示了 <strong><code>constexpr</code></strong> 变量, 函数, 以及用户自定义类型。 在 <code>main()</code> 最后, <strong><code>constexpr</code></strong> 成员函数 <code>GetValue()</code> 是在运行时调用的，因为其返回值没有被要求在编译时确定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass by value</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">float</span> <span class="title">exp</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> :</span><br><span class="line">        n % <span class="number">2</span> == <span class="number">0</span> ? <span class="built_in">exp</span>(x * x, n / <span class="number">2</span>) :</span><br><span class="line">        <span class="built_in">exp</span>(x * x, (n - <span class="number">1</span>) / <span class="number">2</span>) * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass by reference</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">float</span> <span class="title">exp2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> :</span><br><span class="line">        n % <span class="number">2</span> == <span class="number">0</span> ? <span class="built_in">exp2</span>(x * x, n / <span class="number">2</span>) :</span><br><span class="line">        <span class="built_in">exp2</span>(x * x, (n - <span class="number">1</span>) / <span class="number">2</span>) * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile-time computation of array length</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">const</span> T(&amp;)[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursive constexpr function</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : n * <span class="built_in">fac</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User-defined type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> i)</span> : _i(i) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// foo is const:</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Foo <span class="title">foo</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">// foo = Foo(6); //Error!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compile time:</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">float</span> x = <span class="built_in">exp</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">float</span> y &#123; <span class="built_in">exp</span>(<span class="number">2</span>, <span class="number">5</span>) &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> val = foo.<span class="built_in">GetValue</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> f5 = <span class="built_in">fac</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nums[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nums2[<span class="built_in">length</span>(nums) * <span class="number">2</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run time:</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The value of foo is &quot;</span> &lt;&lt; foo.<span class="built_in">GetValue</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="constexpr-和-const-的异同"><a href="#constexpr-和-const-的异同" class="headerlink" title="constexpr 和 const 的异同"></a>constexpr 和 const 的异同</h2><p><strong>相同处：</strong><br/><br><strong><code>constexpr</code></strong> 和 <strong><code>const</code></strong> 一样可以用来修饰变量：试图修改 <strong><code>constexpr</code></strong> 变量时，编译器将会报警。一个 <strong><code>constexpr</code></strong> 整型值能够用在任何 <strong><code>const</code></strong> 整型值可以用的地方，例如模板参数和数组的申明。</p>
<p><strong>不同处：<br/><br><strong><code>constexpr</code></strong> 还可以修饰函数和类的构造函数。</strong><code>constexpr</code>** 表示值或者返回值是常量，并且如果可能，在编译时计算它们。<br>当一个值在编译时计算而不是运行时计算时，它能够使程序运行得更快，并使用更少的内存。</p>
<p>所有的 <strong><code>constexpr</code></strong> 对象都是 <strong><code>const</code></strong> 的，但不是所有的 <strong><code>const</code></strong> 对象都是 <strong><code>constexpr</code></strong> 的。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sz;                             <span class="comment">// non-constexpr variable</span></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize1 = sz;     <span class="comment">// error! sz&#x27;s value not</span></span><br><span class="line">                                    <span class="comment">// known at compilation</span></span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="keyword">int</span>, sz&gt; data1;          <span class="comment">// error! same problem</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize2 = <span class="number">10</span>;     <span class="comment">// fine, 10 is a </span></span><br><span class="line">                                    <span class="comment">//compile-time constant</span></span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="keyword">int</span>, arraySize2&gt; data2;  <span class="comment">// fine, arraySize2</span></span><br><span class="line">                                    <span class="comment">// is constexpr</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sz;                             <span class="comment">// as before</span></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> arraySize = sz;          <span class="comment">// fine, arraySize is</span></span><br><span class="line">                                    <span class="comment">// const copy of sz</span></span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="keyword">int</span>, arraySize&gt; data;    <span class="comment">// error! arraySize&#x27;s value</span></span><br><span class="line">                                    <span class="comment">// not known at compilation</span></span><br></pre></td></tr></table></figure>

<h2 id="应该使用-constexpr-的场景"><a href="#应该使用-constexpr-的场景" class="headerlink" title="应该使用 constexpr 的场景"></a>应该使用 constexpr 的场景</h2><p>只要允许，尽可能使用 **<code>constexpr</code>**，当值在编译时计算而不是运行时计算时，它能够使程序运行得更快，并使用更少的内存。</p>
<h2 id="不应该使用-constexpr-的场景"><a href="#不应该使用-constexpr-的场景" class="headerlink" title="不应该使用 constexpr 的场景"></a>不应该使用 constexpr 的场景</h2><p><strong><code>constexpr</code></strong> 是对象或者函数接口的一部分，所以如果你使用了 <strong><code>constexpr</code></strong> 但反悔了，移除 <strong><code>constexpr</code></strong> 可能会导致大量的调用代码编译失败。(比如添加 I/O 操作用于调试或者性能调优可能导致这样的问题，因为 I/O 语句通常不是在 <strong><code>constexpr</code></strong> 函数中执行的。)</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><p>Microsoft Docs (<a href="https://docs.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=msvc-160">https://docs.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=msvc-160</a>)</p>
</li>
<li><p>Effective Modern C++</p>
</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 noexcept 我们需要知道什么？</title>
    <url>/2021/02/07/cplusplus/how-to-use-noexcept/</url>
    <content><![CDATA[<h2 id="要点回顾"><a href="#要点回顾" class="headerlink" title="要点回顾"></a>要点回顾</h2><blockquote>
<p>此部分方便知识点快速回顾，首次阅读请从引言部分开始。</p>
</blockquote>
<ul>
<li><p><code>noexcept(true)</code> 或者 <code>noexcept</code>  表示函数不会抛出或者传递异常，如果函数发生异常，将调用 <code>std::terminate</code> 立即终止程序。</p>
</li>
<li><p><code>noexcept(false)</code> or 或者不使用 <code>noexcept</code> (析构函数或释放函数默认声明为 <code>noexcept</code>), 表示函数所有可能的异常都会被抛出。</p>
</li>
<li><p>建议将所有不会抛出异常(包括以后)的函数声明为 <code>noexcept</code>，当函数声明为 <code>noexcept</code> 后，编译器能够在一些不同的上下文环境中产生更加高效的代码。</p>
</li>
<li><p>函数可以标记为 <code>noexcept</code> 当且仅当内部调用的所有函数也都直接或者间接的标记为 <code>noexcept</code> 或者 <code>const</code>。</p>
</li>
<li><p><strong>声明一个函数为 <code>noexcept</code>, 之后又去掉 <code>noexcept</code> 标记，会影响到调用端的代码。</strong></p>
</li>
</ul>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>noexcept 是自 C++11 引入的新特性，指定函数是否可能会引发异常。</p>
<h2 id="noexcept-是什么？"><a href="#noexcept-是什么？" class="headerlink" title="noexcept 是什么？"></a>noexcept 是什么？</h2><p>以下是 noexcept 的标准语法：</p>
<blockquote>
<p><em>noexcept-expression</em>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>noexcept</code><strong><br>&nbsp;&nbsp;&nbsp;&nbsp;</strong><code>noexcept(** *constant-expression* **)</code></strong></p>
</blockquote>
<p><em>constant-expression</em> 是一个 <code>bool</code> 类型的常量表达式，是一种异常规范（<em>exception specification</em>），属于C++的语言特性，表示是否会发生异常。</p>
<p><code>noexcept</code> 等效于 <code>noexcept(true)</code>。</p>
<p><code>noexcept(true)</code> 或者 <code>noexcept</code>  表示函数不会抛出或者传递异常，如果函数发生异常，将调用 <code>std::terminate</code> 立即终止程序。</p>
<p><code>noexcept(false)</code> or 或者不使用 <code>noexcept</code> (析构函数或释放函数默认声明为 <code>noexcept</code>), 表示函数所有可能的异常都会被抛出。</p>
<h2 id="应该使用-nonexcept-的情形"><a href="#应该使用-nonexcept-的情形" class="headerlink" title="应该使用 nonexcept 的情形"></a>应该使用 nonexcept 的情形</h2><p>建议将所有不会抛出异常(包括以后)的函数声明为 <code>noexcept</code>。<br>当函数声明为 <code>noexcept</code> 后，编译器能够在一些不同的上下文环境中产生更加高效的代码。</p>
<h2 id="不应该使用-nonexcept-的情形"><a href="#不应该使用-nonexcept-的情形" class="headerlink" title="不应该使用 nonexcept 的情形"></a>不应该使用 nonexcept 的情形</h2><p>函数可以标记为 <code>noexcept</code> 当且仅当内部调用的所有函数也都直接或者间接的标记为 <code>noexcept</code> 或者 <code>const</code>。</p>
<p>编译器没有义务检查所有层级代码是否会抛出异常到 <code>noexcept</code> 函数。<br>如果标记了 <code>noexcept</code> 的函数确实抛出了异常，那么<code>std::terminate</code>将会被立即调用，并且不能保证函数内部的对象能够被析构。</p>
<p>比起优化，正确性更为重要。</p>
<p>当你在最开始声明一个函数为 <code>noexcept</code>, 而后又反悔想要去掉 <code>noexcept</code> 标记，那么你将会影响到调用端的代码。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面的函数被标记为有条件的 <code>noexcept</code>：函数是否为 <code>noexcept</code> 取决于 <code>noexcept</code> 的子句表达式是否为 <code>noexcept</code>。</p>
<p>例如，有两个包含 Widget 对象的数组，交换两个数组的函数是否为 <code>noexcept</code> 取决于 交换两个数组中元素的函数是否为 <code>noexcept</code>，即，交换两个 Widget 对象是否为 <code>noexcept</code>。</p>
<p>因此 Widget 对象 swap 的实现决定了 Widget 数组的交换函数是否为 <code>noexcept</code>。</p>
<p>同样地，包含 Widgets 的 std::pair 对象的交换函数是否应该为 <code>noexcept</code> 取决于交换两个 Widget 对象是否为 <code>noexcept</code>。 </p>
<p>上层的数据结构操作可以为 <code>noexcept</code> 仅当下层的数据结构操作为 <code>noexcept</code>。这就促使你，只要允许，就尽可能地提供 <code>noexcept</code> 的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">size_t</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T (&amp;a)[N], T (&amp;b)[N])</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(*a, *b)))</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(pair&amp; p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(first, p.first)) &amp;&amp; <span class="keyword">noexcept</span>(swap(second, p.second)))</span></span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>noexcept</code> 是函数接口的一部分，这意味着调用者会依赖它。</li>
<li><code>noexcept</code> 函数可优化性要高于 <code>non-noexcept</code> 函数。</li>
<li><code>noexcept</code> 用在数据移动，交换，内存释放函数，析构函数中会更有价值。</li>
<li>大多数函数本质上是属于 <code>non-noexcept</code> 的。</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在 C++17 之前还有一种异常规范 (dynamic exception pecification) <code>throw(optional_type_list)</code>。<br>C++17 之后 <code>throw(optional_type_list)</code> 已被移除(除了 <code>throw()</code>)，<code>throw()</code> 等同于 <code>noexcept</code>。</p>
<p>应该避免使用 <code>throw(optional_type_list)</code> 或者 <code>throw()</code>。</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>Basic C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hi-Steven</title>
    <url>/1901/04/06/hexo/Hi-Steven/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>!</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
